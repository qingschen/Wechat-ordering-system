# 		Maven

## 下载Maven

1. 官网下载bin.zip

2. 解压到全英文目录（C:\Program Files\Java)

3. 修改环境变量：

   ```
   1.直接在path中添加路径
   2.在系统变量中添加MAVEN_HOME,再在PATH中添加MAVEN_HOME
   也就是说主要还是运行PATH，调用关系。
   ```

## maven构建

### 创建第一个maven项目

1. configure-setting-Build→Execution,Deployment→Build Tools→Maven

   ```
   Maven home directory：改为自己下载的Maven地址。
   User setting file：改为下载的Maven文件夹下的conf\setting.xml,并选中后面的override选项
   Local repository：maven下载远程文件时，存在本地的位置，暂时不动，override也没选中。
   ```

   

2. 创建项目→选择Maven项目，sdk默认为1.8（配置的环境变量）→选择org.apache.maven.archetypes:maven-archetype-webapp→next;

   ​	<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125192622832.png" alt="image-20220125192622832" style="zoom:80%;" />

```
Name：新项目名称
Location：项目保存地址
Artifact Coordinates：
	Groupid：公司名称(org.example,表示示例项目)
	ArtifactId：项目名称，一般是example-Name
	Version：迭代版本，开始是1.0，SNAPSHOT表示是一个快照版本，也就是说项目在创建初期
```

3. 项目信息的确认→finish。

   <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125193107392.png" alt="image-20220125193107392" style="zoom:80%;" />

   4. idea开始构建Maven，但因为外网访问可能会导致下载失败，未下载成功的话需要配置镜像。（在使用的Maven文件夹下的config/setting.xml中的mirrors中添加镜像。（下为阿里云镜像）

      ```
      <mirror>
          <id>nexus-aliyun</id>
          <name>Nexus aliyun</name>
          <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
          <mirrorOf>central</mirrorOf>
      </mirror>
      ```

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125195348159.png" alt="image-20220125195348159" style="zoom:80%;" />

​				配置完成！！！

### 引入Maven依赖

1. 访问https://mvnrepository.com/，在网站上搜索需要的jar包，点击需要的包

   ```
   示例：搜索servlet，点击servlet-api，选择对应版本，如3.1.0，点击链接，就能看到配置文件
   ```

   <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125200025538.png" alt="image-20220125200025538" style="zoom:80%;" />

2. 复制相应的代码到pom.xml的<dependencies><dependencies>里面

3. 点击右上角更新Maven，或者设置自动更新

```
Maven可以通过修改dependencies中的内容，自动进行配置的修改
如果pom.xml的dependencies中的version，maven会自动进行版本的替换
```

### 下载Maven插件

```
下载插件和引入依赖同理。
在https://maven.apache.org/(maven官网)中查找对应插件并下载
这里下载tomat最新版本。（将对应代码复制到<plugins><plugins>)
```

### Maven运行方式

#### 使用java命令运行

1. 点击idea运行小锤子旁边的Add Configuration（或Edit Configuration）→点击+→选择Maven。
2. 选择Maven后，检查或填写Name，在Command line：输入tomcat7:run（即使用Tomcat7来运行该项目，idea内置了Tomcat7）
3. 点击OK,然后运行。

#### 添加到本地的Tomcat中运行

1. 点击idea运行小锤子旁边的Add Configuration（或Edit Configuration）→点击+→选择Tomcat Server-local。

2. 点击Application server：后面的configure... 选中需要的Tomcat，点击OK

   <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125202523365.png" alt="image-20220125202523365" style="zoom:80%;" />

   3. 点击Deployment→点击+→点击Artifact...，将项目（此处是trains01：war）添加到Tomcat中，即可启动。（下图中可以选择两种启动方式）

      ![image-20220125203052346](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125203052346.png)

   4. Tomcat会自动打开web网页，若没有自动打开，可以在edit configuration中查看URL进行访问。

### 构建中的bug

```
Generating project in Batch mode
```

创建Maven项目时挂死在构建项目环节。

防火墙（国家的防火墙），切换镜像即可。

## Maven文件结构

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125203826720.png" alt="image-20220125203826720" style="zoom:80%;" />

```
bin:binary,用于存放二进制可执行文件
boot:存放Maven的类加载器，存放自己的jar包，类库等，对其操作较少
cof:config,存放maven配置文件
lib:library，依赖的jar包
```

## Maven仓库Repository

### 分类

#### 远程仓库/中央仓库

中央仓库在国外，因此下载较慢，国内会提供镜像仓库，定时同步中央仓库的内容。

#### 本地仓库

```
C:/Users/用户名/.m2/repository/
```

#### 私有服务器

### 结构

![image-20220127154822398](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127154822398.png)

```
普通用户直接连接到远程仓库进行下载上传；企业用户通过企业的私有服务器进行下载上传，私有服务器再和远程仓库进行通信。
```

### 配置

![image-20220127155115873](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127155115873.png)

本地仓库的配置

```
<localRepository>C:/Program Files/Java/apache-maven-3.6.1/usrlibs</localRepository>	
<--! 在这里将路径默认的\都改为了/ -->
本地仓库替换以后，无法从远程仓库下载资源，所以后面又改回了默认本地仓库。
```

## Maven核心组件：配置

### 全局配置：settings.xml

配置默认使用jdk1.8，在<profiles></profiles>中添加如下代码：

```
	<profile>
		<id>jdk-1.8</id>

		<activation>
			<activeByDefault>true</activeByDefault>
			<jdk>1.8</jdk>
		</activation>

		<properties>
			<maven.compiler.source>1.8</maven.compiler.source>
			<maven.compiler.target>1.8</maven.compiler.target>
			<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
		</properties>
  	</profile>
```

### 项目配置：pom.xml

```
E:\work\工作\Maven课程资源\pom_sample.xml
```



## Maven基础组件：gav坐标

- groupId
- artifactId
- version

通过gav坐标导入jar包

![image-20220127162954339](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127162954339.png)

```
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.21</version>
</dependency>
```

## Maven命令操作：mvn命令

![image-20220127164315166](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127164315166.png)

在terminal中输入命令可完成对应操作。

## 基础组件： 生命周期

![image-20220127165818173](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127165818173.png)

![image-20220127165836015](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127165836015.png)

## Maven项目结构

![image-20220127165930457](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127165930457.png)

## 构建Maven项目的方式（无需打开IDEA)

1. 底层手动实现

   ```
   1.根据Maven项目结构构建文件夹
   2.在pom.xml中写相应的配置
   3.通过命令行，进入到对应的项目目录下，通过输入mvn命令和运行命令，可以完成项目的运行
   ```

2. 命令方式构建
3. 使用工具构建（IDEA构建）

## archetype项目骨架加载慢的问题

1. 添加archetype-catalog.xml到指定目录下

```
将archetype-catalog.xml（E:\work\工作\Maven课程资源）粘贴到C:\Program Files\Java\apache-maven-3.3.9\usrlibs\org\apache\maven\archetype\archetype-catalog\3.2.1中
```

2. 在IDEA中进行配置，配置后OK

```
settings → Build，Execution，Deployment → Build Tools → Maven → Runner
	在VM Options：后面的文本框中添加： -DarchetypeCatalog=local
```

经过配置以后，加载就可以变快。

## 依赖的范围管理

```
依赖的jar包在项目中的作用范围
```

![image-20220127190100614](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127190100614.png)

![image-20220127190140167](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127190140167.png)

## 父子项目依赖传递

1. 首先创建父项目

   1. 先创建一个项目example-trains-father.

   2. 添加父项目打包方式，直接在URL下面添加，即是<project></project>结构体内的

      ```
      <!-- 父项目打包方式 -->
        <packaging>pom</packaging>
      ```

   3. 给父项目添加相关依赖

      ```
      在<properties></properties>结构体中，可以通过下列语句定义版本号：
      	<junit.version>4.11</junit.version>
          <spring.version>5.2.8.RELEASE</spring.version>
      然后在<dependecies></dependecies>（其他地方应该也可以）中可以使用${junit.version}的方式，调用版本号，即${junit.version} = 4.11
      示例：
      	<dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
          </dependency>
      ```

   4. 添加<dependencyManagement></dependencyManagement>，也是<project></project>结构体内的

      ```
      <!-- 父项目中同一管理的依赖：依赖容器，在子项目中使用的时候才会引入，父项目中并不会导入该类目的jar包 -->
        <dependencyManagement>
          <dependencies>
            <dependency>
              <groupId>log4j</groupId>
              <artifactId>log4j</artifactId>
              <version>${log4j.version}</version>
            </dependency>
          </dependencies>
        </dependencyManagement>
      ```

2. 再创建子项目

   1. 还是先创建一个项目example-trains-children.

   2. 在子项目中添加如下代码，实现继承关系，同样添加在<project></project>中

      ```
      	<parent>
            	<groupId>org.example</groupId>
            	<artifactId>example-trains-father</artifactId>
           	<version>1.0-SNAPSHOT</version>
          	<relativePath>../exampletrainsfather/pom.xml</relativePath>
        	</parent>
      
        <!--子项目会自动继承父项目的groupId，所以子项目不需要再写groupId，因此将新建项目时写的groupId注释掉-->
        <!--<groupId>org.example</groupId>-->
      ```

      此时，子项目会自动导入父项目的<dependencies></dependencies>中的所有jar包

   3. 若要在子项目中的<dependencies></dependencies>添加父项目中的<dependencyManagement></dependencyManagement>中的依赖，则此时无需指定version，会自动加载父类指定的version

      ```
      <!--无需指定版本号-->
            <dependency>
                <groupId>log4j</groupId>
                <artifactId>log4j</artifactId>
            </dependency>
      ```

      也就是通过<dependencyManagement></dependencyManagement>实现了子项目依赖的统一管理。

### 注意点

父项目的打包方式必须是pom

```
<packaging>pom</packaging>
```

### 优点

1. 通过父子项目，能够合理有效的复用依赖jar包
2. 子项目相互独立更加便于敏捷开发和独立管理

### 缺点

父子项目之间的系统集成性能较差

## 聚合项目依赖传递(主流方式)

1. 先创建聚合的顶级项目

   1. 先创建一个新项目example-trains-aggregation

   2. 将该项目的打包方式设为pom

      ```
      <packaging>pom</packaging>
      ```

2. 再创建聚合子项目，在顶级项目上new → module，仍创建maven，子项目中会默认有以下标签

   ![image-20220127200926455](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127200926455.png)

   ```
   	<parent>
           <artifactId>example-trains-aggregation</artifactId>
           <groupId>org.example</groupId>
           <version>1.0-SNAPSHOT</version>
       </parent>
   ```

   ​	父项目中会自动生成以下信息：

   ```
     <modules>
       <module>example-trains-aggregation-subclass</module>
     </modules>
   ```

### 优点

项目之间的整体性较高，便于系统集成和维护。

## 常见插件

```
https://maven.apache.org/plugins/index.html，查看插件
```

在<plugins></plugins>中添加想要的插件。

## 私有服务器

```
保障团队内部依赖共享
安全性较好
```

## Maven中的依赖冲突

### 直接冲突

![image-20220127210347027](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127210347027.png)

![image-20220127210514849](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127210514849.png)

```
解决：排除一个低版本的依赖，通过添加<exclusion></exclusion>实现
<dependency>
      <groupId>commons-beanutils</groupId>
      <artifactId>commons-beanutils</artifactId>
      <version>1.9.4</version>
      <exclusions>
        <exclusion>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
        </exclusion>
      </exclusions>
    </dependency>
```

### 传递冲突

![image-20220127210406707](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220127210406707.png)

```
项目Project依赖于项目A，而项目A依赖于项目B和C。此时Project依旧会引入B和C，若不想依赖C，则通过<exclusion></exclusion>排除C
```

# Spring

## Spring HelloWorld

1. 创建一个普通的Maven项目，然后引入spring-context依赖

   ```
   <dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-context</artifactId>
         <version>5.1.9.RELEASE</version>
       </dependency>
   ```

2. 在resources目录下创建一个spring的配置文件，命名为ApplicationContext.xml

   <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220202165247290.png" alt="image-20220202165247290" style="zoom:80%;" />

3. 在ApplicationContext.xml中的<Beans></Beans>结构体中，添加

   ```
   <bean class = "org.example.Book" id = "book" />
   ```

   通过反射机制，创建一个Book类对象交给Bean容器。

4. 可以在其他类中，通过以下两种方式获得配置文件

   ```
   //通过当前resources的相对路径获取
   ClassPathXmlApplicationContext ctx1 = new ClassPathXmlApplicationContext("applicationContext.xml");
   //通过绝对路径获取
   FileSystemXmlApplicationContext ctx2 = new FileSystemXmlApplicationContext("E:\\workspace\\IdeaProjects\\example-springHelloWorld\\src\\main\\resources\\applicationContext.xml");
   ```

5. 可以通过以下方法使用对象

   ```
   Book book1 = (Book) ctx1.getBean("book");
   Book book2 = ctx1.getBean("book", Book.class);
   Book book3 = ctx1.getBean(Book.class);//当且仅当<Beans></Beans>中只有一个Book对象时可使用
   ```

## 属性的注入-xml注入

1. 构造方法注入：通过给定构造参数的name和value创建对象

   ```
   <bean class="org.example.Book" id = "book1">
   	<constructor-arg name="id" value="2"/>
   	<constructor-arg name="name" value="Alive"/>
   	<constructor-arg name="price" value="32"/>
   </bean>
   ```

2. set方法注入：调用类的set方法进行属性值的设定

   ```
   <bean class="org.example.Book" id="book2">
       <property name="id" value="3"/>
       <property name="name" value="Cycle"/>
       <property name="price" value="50"/>
   </bean>
   ```

3. p名称空间注入，本质上是set方法注入，用的较少

   ```
   <bean class="org.example.Book" id="book3"
               p:id="4" p:name="西游记" p:price="100"></bean>
   ```

4. 外部Bean的注入：当外部类不是new出来的，而是在调用Builder方法的过程中配置一些默认的参数，辞职通过静态工厂注入或实例工厂注入来提供实例。

   1. 静态工厂注入

      1. 先创建静态工厂类

      ```
      public class OkHttpStaticFactory {
          private static OkHttpClient okHttpClient;
          public static OkHttpClient getInstance(){
              if(okHttpClient == null){
                  okHttpClient = new OkHttpClient.Builder().build();
              }
              return okHttpClient;
          }
      }
      ```

       2. 再进行注入

          ```
          <!--使用静态工厂中的getInstace（）方法获取实例-->
          <bean class="org.example.OkHttpStaticFactory" factory-method="getInstance" id="okHttpClient1"/>
          ```

   2. 动态工厂注入

      1. 先创建动态工厂类

         ```
         public class OkHttpFactory {
             private  OkHttpClient okHttpClient;
             public  OkHttpClient getInstance(){
                 if(okHttpClient == null){
                     okHttpClient = new OkHttpClient.Builder().build();
                 }
                 return okHttpClient;
             }
         }
         ```

      2. 再进行注入

         ```
         <!--使用动态工厂获取实例-->
         <!--首先要先获取动态工厂实例-->
         <!--再调用实例的getInstance方法-->
         <bean class="org.example.OkHttpFactory" id="okHttpFactory"/>
         <bean class="okhttp3.OkHttpClient" factory-bean="okHttpFactory" factory-method="getInstance" id="okHttpClient2"/>
         ```

5. 复杂属性的注入:对象注入、数组注入、Map注入、Properties注入

   其中用到的User类中的属性：

   ```
    private Integer id;
    private String name;
    private Integer age;
    private Book book;
    private String[] favorites;
    private List<Book> books;
    private Map<String,Integer> map;
    private Properties info;
   ```

   User注入：

   ```
   <bean class="org.example.User" id="user1">
       <property name="id" value="1"/>
       <property name="name" value="小红"/>
       <property name="age" value="12"/>
       <!--数组注入-->
       <property name="favorites">
           <array>
               <value>足球</value>
               <value>篮球</value>
               <value>网球</value>
           </array>
       </property>
       <!--对象注入-->
       <!--该对象已经在前面注入过了，也可以新注入一个对象，像下面的book5一样-->
       <property name="book" ref="book1"/>
       <!--对象数组注入-->
       <property name="books">
           <list>
               <ref bean="book1"/>
               <ref bean="book2"/>
               <ref bean="book3"/>
               <bean class="org.example.Book" id="book5">
                   <property name="id" value="1"/>
                   <property name="name" value="红楼梦"/>
                   <property name="price" value="23"/>
               </bean>
           </list>
       </property>
       <!--map注入-->
       <property name="map">
           <map>
               <entry key="age" value="99"/>
               <entry key="phone" value="12136"/>
           </map>
       </property>
       <!--Properties注入-->
       <property name="info">
           <props>
               <prop key="age">99</prop>
               <prop key="name">小红</prop>
               <prop key="height">168</prop>
           </props>
       </property>
   </bean>
   ```

## 属性的注入-Java配置

1. 在java-groupId-javaconfig中创建JavaConfig类，添加@configration注释使之成为注解类

   ```
   //添加 @Configuration注解表示一个类是注解类
   @Configuration
   public class JavaConfig {
   //    将sayHello类注入Bean中
       @Bean
       SayHello sayHello(){
           return new SayHello();
       }
   }
   ```

   ```
   //该类与JavaConfig在一个包下
   public class SayHello {
       public String sayHello(String name) {
           return "hello, " + name;
       }
   }
   ```

2. 调用类对象

   ```
   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class);
   SayHello sayHello = ctx.getBean("sayHello", SayHello.class);//Bean的名字默认是方法名
   ```

## 自动化配置

四个注解：在类头上添加如下四个注解

```
@Service：在Service层上使用该标志添加注解
@Repository：在dao层上使用该标志添加注解
@Controller：在Controller层上使用该标志添加注解
@Component：在其他组件上添加注解时，使用@Component
```

```
//添加注解示例
@Service
public class javaService {
    public void service(){
        System.out.println("Service");
    }
}
```

添加完成后，自动化扫描有两种：

 1. Java配置

    ```
    //添加 @Configuration注解表示一个类是注解类
    //添加@ComponentScan(basePackages = "org.example")可扫描指定包名下的所有四类注解
    //默认情况下扫描当前包中注解
    @Configuration
    @ComponentScan(basePackages = "org.example")
    public class JavaConfig {
    }
    ```

    ```
    //使用
    //注解的实例名默认是类名的首字母小写
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class);
    JavaService javaService = ctx.getBean("javaService", JavaService.class);
    ```

 2. xml文件配置

    ```
    <!--表示扫描org.example包下的所有注解-->
    <context:component-scan base-package="org.example"/>
    ```

    ```
    //使用
    ClassPathXmlApplicationContext ctx1 = new ClassPathXmlApplicationContext("applicationContext.xml");
    FileSystemXmlApplicationContext ctx2 = new FileSystemXmlApplicationContext("E:\\workspace\\IdeaProjects\\example-springHelloWorld\\src\\main\\resources\\applicationContext.xml");
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class);
    JavaService javaService = ctx1.getBean("javaService", JavaService.class);
    ```

### 对象注入

```
@Autowired：该类型对象只有一个时才能调用
@Resources
@Injected
```

## 条件注解 （属于手动注入）

例：根据不同的环境打印环境下的查询目录语句

```
//首先创建一个打印语句的接口
public interface ShowCmd {
    String showCmd();
}
```

```
//在Windows和linux下实现该接口
public class WinShowCmd implements ShowCmd {
    @Override
    public String showCmd(){
        return "dir";
    }
}
public class LinuxShowCmd implements ShowCmd{
    @Override
    public String showCmd(){
        return "ls";
    }
}
```

```
//实现Windows下和linux的条件接口,用于判断当前处于哪个环境下
public class WindowsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext ctx, AnnotatedTypeMetadata metadata){
        return ctx.getEnvironment().getProperty("os.name").toLowerCase().contains("windows");
    }
}
public class LinuxCondition implements Condition {
    @Override
    public boolean matches(ConditionContext ctx, AnnotatedTypeMetadata metadata){
        return ctx.getEnvironment().getProperty("os.name").toLowerCase().contains("linux");
    }
}
```

```
//在javaConfig类中注入条件注解
@Bean("showCmd")
@Conditional(WindowsCondition.class)
ShowCmd winCmd(){
    return new WinShowCmd();
}

@Bean("showCmd")
@Conditional(LinuxCondition.class)
ShowCmd linuxCmd(){
    return new LinuxShowCmd();
}
```

```
//main函数中使用
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class);
ShowCmd showCmd = (ShowCmd)ctx.getBean("showCmd");
System.out.println(showCmd.showCmd());
```

## 混合配置：Java配置 + XML配置

```
@Configuration
@ImportResource("classpath:applicationContext.xml")
public class JavaConfig{
}
```

## AOP : 面向切面编程

### 几个概念

| 切点             | 要添加代码的地方，称作切点       |
| ---------------- | -------------------------------- |
| **通知（增强）** | **通知就是向切点动态添加的代码** |
| **切面**         | **切点 + 通知**                  |
| **连接点**       | **切点的定义**                   |

### 基于JDK的动态代理

```
//首先创建一个MyCalculator接口
public interface MyCalculator {
    int add(int a, int b);
}

//实现该接口
public class MyCalculatorImpl implements MyCalculator{
    @Override
    public int add(int a, int b){
        return a + b;
    }
}
```

```
//代理类
public class CalculatorProxy {
    public static Object getInstance(final MyCalculatorImpl myCalculator){
        return Proxy.newProxyInstance(CalculatorProxy.class.getClassLoader(), myCalculator.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     *
                     * @param proxy 代理对象
                     * @param method 代理的方法
                     * @param args 方法的参数
                     * @return
                     * @throws Throwable
                     * 当调用原方法时，会调用invoke方法
                     * invoke为原方法实际返回值
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(method.getName() + "方法开始执行了");
                        Object invoke = method.invoke(myCalculator, args);//调用原方法，invoke为原方法的返回值
                        System.out.println("add方法返回值" + invoke);
                        System.out.println(method.getName() + "方法执行结束了");
                        return invoke;

                    }
                });
    }
}
```

```
//main中调用
public static void main(String[] args) {
    MyCalculatorImpl myCalculator = new MyCalculatorImpl();
    MyCalculator calculator = (MyCalculator)CalculatorProxy.getInstance(myCalculator);
    int add = calculator.add(3, 4);
    System.out.println("add = " + add);
}
```

### 统一定义切点

```
/**
* 可以统一定义切点
* 第一个*表示要拦截的目标方法返回值任意
* 第二个*表示包中的任意类
* 第三个*表示类中的任意方法
* 最后面两个点表示方法参数任意，个数任意，类型任意
*/
@Pointcut("execution(* org.aop.*.*(..))")
public void pointcut(){
}
```

```
//execution函数
语法：execution(修饰符  返回值  包.类.方法名(参数) throws异常)
修饰符，一般省略
    public                公共方法
    *                        任意
返回值，不能省略
    void                   返回没有值
    String                返回值字符串
    *                       任意
方法名，不能省略
    addUser					固定方法
    add*					以add开头
    *Do						以Do结尾
    *						任意
(参数)
     ()						无参
     (int)					一个整型
     (int ,int)				两个
     (..)					参数任意
throws ,可省略，一般不写。
```

### 五种通知

- 前置通知
- 后置通知
- 异常通知
- 返回通知
- 环绕通知

```
//环境配置
<!--导入依赖-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.1.9.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.5</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.9.5</version>
</dependency>
```

```
//被代理的接口和实现接口的类
public interface MyCalculator {
    int add(int a, int b);
    void min(int a, int b);
}

//实现接口的类，添加到Bean中
@Component
public class MyCalculatorImpl implements MyCalculator {
    @Override
    public int add(int a, int b) {
        int ans = a + b;
        System.out.println(ans);
        return ans;
    }

    @Override
    public void min(int a, int b) {
        System.out.println(a + " - " + b + " = " + (a - b));
    }

}
```

```
//使用Java配置扫描自动的注入
@Configuration
@ComponentScan
@EnableAspectJAutoProxy //开启自动代理
public class JavaConfig {
}
```

```
//通知类
@Component  //自动化配置的注解
@Aspect //表示是一个切面
public class LogAspect {
    /**
     * 可以统一定义切点
     * 第一个*表示要拦截的目标方法返回值任意
     * 第二个*表示包中的任意类
     * 第三个*表示类中的任意方法
     * 最后面两个点表示方法参数任意，个数任意，类型任意
     */
    @Pointcut("execution(* org.aop.*.*(..))")
    public void pointcut(){

    }

    /**
     * 前置通知，在目标方法执行之前执行，注解中需要填入切入点
     * @param joinPoint
     */
    @Before(value = "pointcut()")
    public void before(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("前置通知: " + name + "方法开始执行了...");
    }

    /**
     * 后置通知，在目标方法执行之后执行
     * @param joinPoint
     */
    @After(value = "pointcut()")
    public void after(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("后置通知: " + name + "方法执行结束了...");
    }

    /**
     * 返回通知，目标方法有返回值是才会触发
     * returning要和形参中的返回值参数一一对应，名称、类型要相同，此处都为r
     * @param joinPoint
     * @param r
     */
    @AfterReturning(value = "pointcut()", returning = "r")
    public void returning(JoinPoint joinPoint, Integer r){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("返回通知: " + name + "返回结果： " + r);
    }

    /**
     * 异常通知，抛出异常时触发
     * e必须是目标方法所抛出的异常或所抛出异常的父类
     * @param joinPoint
     * @param e
     */
    @AfterThrowing(value = "pointcut()", throwing = "e")
    public void  afterThrowing(JoinPoint joinPoint, Exception e){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("异常通知: " + name + "抛出异常： " + e.getMessage());
    }

    @Around(value = "pointcut()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint){
        Object proceed = null;
        try{
            //这个相当于jdk实现中的method.invoke()，调用原方法
            //在该方法之前之后添加日志，就相当于前置、后置通知
            System.out.println("环绕通知：方法开始执行");
            proceed = proceedingJoinPoint.proceed();
            System.out.println("环绕通知：方法执行结束");
        }catch (Throwable throwable){
            throwable.printStackTrace();
        }
        return proceed;
    }
}
```

```
//main调用
public class Main {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class);
        MyCalculator myCalculator = ctx.getBean(MyCalculator.class);//使用接口类获取类实例
        myCalculator.add(3, 4);
        myCalculator.min(3,4);
    }
}
```

### xml配置Aop

```
//以上面的为基础
//LogAspectXml删除了LogAspect中的所有注解
public class LogAspectXml {
    /**
     * 前置通知，在目标方法执行之前执行，注解中需要填入切入点
     * @param joinPoint
     */
    public void before(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("前置通知: " + name + "方法开始执行了...");
    }

    /**
     * 后置通知，在目标方法执行之后执行
     * @param joinPoint
     */
    public void after(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("后置通知: " + name + "方法执行结束了...");
    }

    /**
     * 返回通知，目标方法有返回值是才会触发
     * returning要和形参中的返回值参数一一对应，名称、类型要相同，此处都为r
     * @param joinPoint
     * @param r
     */
    public void returning(JoinPoint joinPoint, Integer r){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("返回通知: " + name + "返回结果： " + r);
    }

    /**
     * 异常通知，抛出异常时触发
     * e必须是目标方法所抛出的异常或所抛出异常的父类
     * @param joinPoint
     * @param e
     */
    public void  afterThrowing(JoinPoint joinPoint, Exception e){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        System.out.println("异常通知: " + name + "抛出异常： " + e.getMessage());
    }

    public Object around(ProceedingJoinPoint proceedingJoinPoint){
        Object proceed = null;
        try{
            //这个相当于jdk实现中的method.invoke()，调用原方法
            //在该方法之前之后添加日志，就相当于前置、后置通知
            System.out.println("环绕通知：方法开始执行");
            proceed = proceedingJoinPoint.proceed();
            System.out.println("环绕通知：方法执行结束");
        }catch (Throwable throwable){
            throwable.printStackTrace();
        }
        return proceed;
    }
}
```

```
//在xml文件中进行注释
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean class="org.aop.LogAspectXml" id="logAspectXml"/>
    <bean class="org.aop.MyCalculatorImpl " id="myCalculator"/>
    <aop:config>
        <aop:pointcut id="pc" expression="execution(* org.aop.*.*(..))"/>
        <aop:aspect ref="logAspectXml">
            <aop:before method="before" pointcut-ref="pc"/>
            <aop:after method="after" pointcut-ref="pc"/>
            <aop:after-returning method="returning" pointcut-ref="pc" returning="r"/>
            <aop:after-throwing method="afterThrowing" pointcut-ref="pc" throwing="e"/>
            <aop:around method="around" pointcut-ref="pc"/>
        </aop:aspect>
    </aop:config>
</beans>
```

```
//main调用
public class MainXml {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        MyCalculator myCalculator = ctx.getBean(MyCalculator.class);
        myCalculator.add(6, 7);
        myCalculator.min(6,7);
    }
}
```

# SpringBoot

## 创建第一个SpringBoot项目

1. new project-Spring Initializr，选择默认的URL

   ```
   Initializr Service URL: http://start.spring.io/
   ```

2. web-spring web

   <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220209151144327.png" alt="image-20220209151144327" style="zoom:50%;" />

3. 删除.mvn mvnw mvnw.cmd

4. 新建HelloController类,通过http://localhost:8080/hello进行访问

   ```
   @RestController
   public class HelloController {
       @RequestMapping(value = "/hello", method = RequestMethod.GET)
       public String say(){
           return "Hello Spring Boot!";
       }
   }
   ```

### 三种启动方式

1. 右击main目录下自动生成的带有main方法的类，选择运行，即可启动

2. cmd启动：进入项目目录下，输入命令启动

   ```
   cd E:\workspace\IdeaProjects\springboot-demo1
   mvn spring-boot:run
   ```

3. 编译项目，然后运行.jar文件

   ```
   mvn install
   cd target
   java -jar springboot-demo-0.0.1-SNAPSHOT.jar
   ```

### 配置文件

```
建议使用.yml文件。
resources-new file-xxxx.yml
```

1. 在yml文件中配置属性，如

   ```
   #注意冒号后面需要跟空格
   name: "Mike"
   ```

2. 在Controller类中使用value注解引入配置值

   ```
   @Value("${name}")
   private String name;
   
   //直接使用
   @RequestMapping(value = "/hello", method = RequestMethod.GET)
   public String say(){
       return name;
   }
   ```

4. 若配置值较多，可以生成一个类进行配置值的注入，如注入girl类

   ```
   #application.yml
   girl:
     age: 18
     grade: A
   ```

   ```
   /**
    * GirlProperties.java
    */
   @Component //注解，将类注入到Bean
   @ConfigurationProperties(prefix = "girl")	//注解，获取配置文件中的数据
   public class GirlProperties {
       private Integer age;
       private String grade;
   
       public Integer getAge() {
           return age;
       }
   
       public void setAge(Integer age) {
           this.age = age;
       }
   
       public String getGrade() {
           return grade;
       }
   
       public void setGrade(String grade) {
           this.grade = grade;
       }
   }
   ```

   ```
   //Controller类
   @Autowired
   private GirlProperties girlProperties;
   
   @RequestMapping(value = "/hello", method = RequestMethod.GET)
   public String say(){
   	return "age: " + girlProperties.getAge() + "  grade: " +  girlProperties.getGrade();
   }
   ```

### 多环境配置

1. 使用多个配置文件

   <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220209161137690.png" alt="image-20220209161137690" style="zoom:80%;" />

2. 在主配置文件中，改变active的值，改变运行环境

   ```
   spring:
     profiles:
       active: dev
   ```

3. 也可以使用多种不同的启动方式，启动不同的环境

## Controller的使用

### 几种注解

| @Controller         | 处理http请求，返回界面，返回的是一个可操作的界面             |
| ------------------- | ------------------------------------------------------------ |
| **@RestController** | **Spring4后新加的注解，原来返回json需要@ResponseBody配合@Controller，返回Json** |
| **@RequestMapping** | **配置URL映射**                                              |
| **@PathVariable**   | **获取URL中的数据**                                          |
| **@RequestParam**   | **获取请求参数的值**                                         |
| **@GetMapping**     | **组合注解,相当于@RequestMapping(value = " ", method = RequestMethod.GET)** |

```
//@RequestMapping使用，url可以使用集合,即可以使用/hi访问，也可以使用/hello访问
 @RequestMapping(value = {"/hi","/hello"}, method = RequestMethod.GET)
 public String say(){
 	return "Hello SpringBoot!";
 }
```

```
//@PathVariable使用，使用http://localhost:8080/12/say访问，输出id:12
@RequestMapping(value = "/{id}/say", method = RequestMethod.GET)
public String say(@PathVariable("id") Integer myId){
	return "id: " + myId;
}
```

```
//@PathVariable使用，使用http://localhost:8080/say/12访问，输出id:12
@RequestMapping(value = "/say/{id}", method = RequestMethod.GET)
public String say(@PathVariable("id") Integer myId){	//PathVariable的参数中的id必须和RequestMapping中的id同名
    return "id: " + myId;
}
```

```
//@RequestParam使用，使用http://localhost:8080/say?id=12访问，输出id:12
@RequestMapping(value = "/say", method = RequestMethod.GET)
public String say(@RequestParam("id") Integer myId){
    return "id: " + myId;
}
```

```
//@RequestParam使用，给id指定默认值，使用http://localhost:8080/say访问，输出id:0
//使用http://localhost:8080/say?id=12访问，输出id:12
@RequestMapping(value = "/say", method = RequestMethod.GET)
public String say(@RequestParam(value = "id", required = false, defaultValue = "0") Integer myId){
	return "id: " + myId;
}
```

## 数据库操作

1. 添加依赖(pom.xml)

   ```
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-jpa</artifactId>
   </dependency>
   
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.48</version>
   </dependency>
   ```

2. 修改配置文件.yml

   ```
   spring:
     profiles:
       active: dev
   #  配置数据库连接
     datasource:
       driver-class-name: com.mysql.jdbc.Driver
       url: jdbc:mysql://127.0.0.1:3306/dbgirl
       username: root
       password: 1234
   #  配置jpa，其中update表示每次重新运行项目时，对数据库进行更新，而不删除原有数据库
     jpa:
       hibernate:
         ddl-auto: update
       show-sql: true
   ```

3. 创建一个dbgirl数据库，否则运行会报错

4. 通过创建类的方式创建表，此处创建girl类

   ```
   //Girl类
   //@Entity会自动创建一个与类同名的表，表的属性与类的属性相对应
   @Entity
   public class Girl {
       @Id
       @GeneratedValue
       private Integer id;//两个标签表示自动生成id，且id值为主键
   
       private Integer age;
   
       private String grade;
   
       public Girl() {
       }
   
       public Integer getId() {
           return id;
       }
   
       public void setId(Integer id) {
           this.id = id;
       }
   
       public Integer getAge() {
           return age;
       }
   
       public void setAge(Integer age) {
           this.age = age;
       }
   
       public String getGrade() {
           return grade;
       }
   
       public void setGrade(String grade) {
           this.grade = grade;
       }
   }
   ```

5. 运行项目，会自动在dbgirl数据库中生成一张girl表。

对数据库进行如下操作：

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220210100222389.png" alt="image-20220210100222389" style="zoom:80%;" />

### 获取数据库中表的所有表项

1. 新建接口GirlRepository，通过该类对数据库进行操作

   ```
   //<对象类型，id类型>
   public interface GirlRepository extends JpaRepository<Girl,Integer> {
   }
   ```

2. 在GirlController中获取girlRepository对象，以及编写函数

   ```
   @Autowired
   private GirlRepository girlRepository;
   
   /**
   * 查询所有女生列表
   * @return
   */
   @GetMapping(value = "/girls")
   public List<Girl> girlList(){
   	return girlRepository.findAll();
   }
   ```

3. 运行项目，即可获取所有女生列表

### 添加一个表项

1. 在上述已经获得girlRepository对象的前提下，进行后续步骤。

2. GirlController中添加方法：

   ```
   /**
   * 添加一个女生
   * @param grade，post传递的grade
   * @param age，post传递的age
   * @return
   */
   @PostMapping(value = "/girls")
   public Girl girlAdd(@RequestParam("grade") String grade,@RequestParam("age") Integer age){
       Girl girl = new Girl();
       girl.setAge(age);
       girl.setGrade(grade);
       return girlRepository.save(girl);
   }
   ```

### 查询 更新 删除

```
@GetMapping(value = "/girls/{id}")
public Optional<Girl> findById(@PathVariable("id") Integer id){
	return girlRepository.findById(id);
}

@PutMapping(value = "/girls/{id}")
public Girl updateById(@PathVariable("id") Integer id,@RequestParam("grade") String grade, @RequestParam("age") Integer age){
    Girl girl = new Girl();
    girl.setId(id);
    girl.setGrade(grade);
    girl.setAge(age);
    return girlRepository.save(girl);
}

@DeleteMapping(value = "/girls/{id}")
public void deleteById(@PathVariable("id") Integer id){
	girlRepository.deleteById(id);
}
```

### 自定义查询

以根据年龄查询为例

1. 在GirlRepository中添加方法

   ```
   //按年龄查询，此处的方法名必须是findByAge
   public List<Girl> findByAge(Integer age);
   ```

2. 在GirlController中编写方法

   ```
   @GetMapping(value = "/girls/age/{age}")
   public List<Girl> girlListByAge(@PathVariable("age") Integer age){
   	return girlRepository.findByAge(age);
   }
   ```

### 事务管理

通过@transactional注解实现事务管理

1. 创建类GirlService，@transactional注解在该类中

   ```
   @Service
   public class GirlService {
       @Autowired
       GirlRepository girlRepository;
   
       //该注解表示两个数据库的操作密不可分，一个失败另一个也会失败
       @Transactional
       public void insertTwo(){
           Girl girlA = new Girl();
           girlA.setAge(19);
           girlA.setGrade("A");
           girlRepository.save(girlA);
   
           Girl girlB = new Girl();
           girlA.setAge(18);
           girlA.setGrade("B");
           girlRepository.save(girlB);
       }
   }
   ```

2. 在GirlController中引入GirlService类对象，并进行函数编写

   ```
   @Autowired
   private GirlService girlService;
   
   @PostMapping(value = "/girls/insertTwo")
   public void girlInsertTwo(){
       girlService.insertTwo();
   }
   ```

### 表单验证

1. 对上面的添加表项方法进行改进，使用Girl对象进行传参，post时依旧使用age和grade传参

   ```
   /**
   * 添加一个女生
   * @return
   */
   @PostMapping(value = "/girls")
   public Girl girlAdd(Girl girl){
       girl.setAge(girl.getAge());
       girl.setGrade(girl.getGrade());
   
       return girlRepository.save(girl);
   }
   ```

2. 在Girl类中，对需要添加表单验证的属性添加@Min标签，可限制最小值，使用注解前需要先导入依赖

   ```
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-validation</artifactId>
   </dependency>
   ```

   ```
   //Girl类
   @Min(value = 18, message = "未成年禁止注册")
   private Integer age;	
   ```

   ```
   //GirlController类
   /**
   * 添加一个女生
   * @return
   */
   //@valid注解表示验证的对象，验证出错时会将出错信息存储在bindingResult中
   @PostMapping(value = "/girls")
   public Girl girlAdd(@Valid Girl girl, BindingResult bindingResult){
       //若发生错误，进行处理，并返回
       if(bindingResult.hasErrors()){
           System.out.println(bindingResult.getFieldError().getDefaultMessage());
           return null;
       }
       girl.setAge(girl.getAge());
       girl.setGrade(girl.getGrade());
   
       return girlRepository.save(girl);
   }
   ```

## AOP处理

与Spring的AOP类似

1. 添加依赖

   ```
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-aop</artifactId>
   </dependency>
   ```

2. 新增包aspect，包内创建新类HttpAspect

   ```
   @Aspect
   @Component
   public class HttpAspect {
       //Logger选择的是org.slf4j.Logger
       //使用日志进行打印
       private final static org.slf4j.Logger logger = LoggerFactory.getLogger(HttpAspect.class);
   
       /**
        * 统一定义切点
        * 第一个*表示要拦截的目标方法返回值任意
        * 路径com.example.demo.controller.GirlController，指定到具体类
        * 第三个*表示类中的任意方法
        * 最后面两个点表示方法参数任意，个数任意，类型任意
        */
       @Pointcut("execution(* com.example.demo.controller.GirlController.*(..))")
       public void pointcut(){
       }
   
       @Before("pointcut()")
       public void doBefore(){
           logger.info("Aop Before!");
       }
   
       @After("pointcut()")
       public void doAfter(){
           logger.info("Aop After!");
       }
   }
   ```

常见的AOP处理：

```
//HttpAspect类
@Aspect
@Component
public class HttpAspect {
    //Logger选择的是org.slf4j.Logger
    private final static org.slf4j.Logger logger = LoggerFactory.getLogger(HttpAspect.class);

    /**
     * 统一定义切点
     * 第一个*表示要拦截的目标方法返回值任意
     * 路径com.example.demo.controller.GirlController，指定到具体类
     * 第三个*表示类中的任意方法
     * 最后面两个点表示方法参数任意，个数任意，类型任意
     */
    @Pointcut("execution(* com.example.demo.controller.GirlController.*(..))")
    public void pointcut(){
    }

    @Before("pointcut()")
    public void doBefore(JoinPoint joinPoint){
//        logger.info("Aop Before!");
        ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        //url
        logger.info("url:{}",request.getRequestURL());

        //method
        logger.info("method:{}",request.getMethod());

        //ip
        logger.info("ip:{}",request.getRemoteAddr());

        //类方法
        logger.info("类方法：{}",joinPoint.getSignature().getDeclaringTypeName()+"."+joinPoint.getSignature().getName());

        //参数
        logger.info("参数：{}",joinPoint.getArgs());
    }

    @After("pointcut()")
    public void doAfter(){
        logger.info("Aop After!");
    }

    //获取返回内容
    @AfterReturning(value = "pointcut()",returning = "object")
    public void doAfterReturnning(Object object){
        logger.info(object.toString());
    }
}
```

## 异常处理

### 普通异常处理

1. 新建Result类，使得使用add方法时，出错或者不出错，返回的类型相同

   ```
   public class Result<T> {
       //错误码
       private Integer code;
   
       //错误描述
       private String msg;
   
       //具体内容
       private T data;
   
       public Integer getCode() {
           return code;
       }
   
       public void setCode(Integer code) {
           this.code = code;
       }
   
       public String getMsg() {
           return msg;
       }
   
       public void setMsg(String msg) {
           this.msg = msg;
       }
   
       public T getData() {
           return data;
       }
   
       public void setData(T data) {
           this.data = data;
       }
   }
   ```

2. 在GirlController类中实现异常处理

   ```
   /**
   * 添加一个女生
   * @return
   */
   //@valid注解表示验证的对象，验证出错时会将出错信息存储在bindingResult中
   @PostMapping(value = "/girls")
   public Result girlAdd(@Valid Girl girl, BindingResult bindingResult){
       //对@Valid表单验证出现的错误进行处理，并返回
       //此处由于年龄限制>=18,所以当年龄小于18时会报错
       if(bindingResult.hasErrors()){
       //            Result result = new Result();
       //            result.setCode(1);
       //            result.setMsg(bindingResult.getFieldError().getDefaultMessage());
       //            result.setData(null);
       //            return result;
       	return ResultUtils.error(1, bindingResult.getFieldError().getDefaultMessage());
       }
   
       //        Result result = new Result();
       //        result.setCode(0);
       //        result.setMsg("成功");
       //        result.setData(girlRepository.save(girl));
       //        return result;
       return ResultUtils.success(girlRepository.save(girl));
   }
   ```

3. 使用ResultUtils进行重复代码的简化

   ```
   public class ResultUtils {
       public static Result error(Integer code,String msg){
           Result result = new Result();
           result.setCode(code);
           result.setMsg(msg);
           result.setData(null);
           return result;
       }
   
       public static Result success() {
           return success(null);
       }
   
       public static Result success(Object obj){
           Result result = new Result();
           result.setCode(0);
           result.setMsg("成功");
           result.setData(obj);
           return result;
       }
   }
   ```

### 统一异常处理

例如将18岁以下的注册者细分

- <10,输出msg：你还在上小学吧，对应异常代码100
- 10~16,输出msg：你还在上中学吧，对应异常代码101

1. 在GirlController类中调用GirlService的方法，具体服务在GirlService中实现

   ```
   /**
   * 根据id判断该条记录的年龄是否违法
   * 并细分违法的类型
   * GirlService中throws了异常，此处也需要throws
   */
   @GetMapping(value = "/girls/getAge/{id}")
   public void girlGetAge(@PathVariable("id") Integer id) throws Exception{
   	girlService.getAge(id);
   }
   ```

2. 在GrilService中实现getAge()方法

   ```
   public void getAge(Integer id) throws Exception{
       Girl girl = girlRepository.findById(id).get();
       Integer age = girl.getAge();
       //年龄小于16的都会抛出异常
       //但细分为两个年龄段进行不同的异常处理
       if(age < 10){
           //输出异常信息
           //使用自定义的异常类，类中有msg和code属性，方便进行code的同一管理
           //age<10属于枚举类中的PRIMARY_SCHOOL
           throw new GirlException(ResultEnum.PRIMARY_SCHOOL.getMsg(),ResultEnum.PRIMARY_SCHOOL.getCode());
       }else if(age < 16){
           //age：10~15属于枚举类中的MIDDLE_SCHOOL
           throw new GirlException(ResultEnum.MIDDLE_SCHOOL.getMsg(),ResultEnum.MIDDLE_SCHOOL.getCode());
       }else{
           //对于16岁以上的，可以进行正常处理
           logger.info("16岁以上...");
       }
   }
   ```

3. 自定义异常类GirlException，将code和msg都写入类中

   ```
   /**
    * 必须继承RuntimeException
    */
   public class GirlException extends RuntimeException {
       /**
        * 异常处理代码
        */
       private Integer code;
   
       public GirlException(String message, Integer code) {
           super(message);
           this.code = code;
       }
   
       public Integer getCode() {
           return code;
       }
   
       public void setCode(Integer code) {
           this.code = code;
       }
   }
   ```

4. 自定义枚举类，进行code与msg的定义

   ```
   /**
    * 对返回异常code及msg进行枚举
    */
   public enum ResultEnum {
       UNKNOWN_ERROR(-1,"未知错误"),
       SUCCESS(0, "成功"),
       PRIMARY_SCHOOL(1,"小学生禁止注册哦~"),
       MIDDLE_SCHOOL(2, "中学生禁止注册哦~"),
       ;
       private Integer code;
       private String msg;
   
       ResultEnum(Integer code, String msg) {
           this.code = code;
           this.msg = msg;
       }
   
       public Integer getCode() {
           return code;
       }
   
       public String getMsg() {
           return msg;
       }
   }
   ```

5. 编写异常处理类，对抛出的异常进行处理

   ```
   /**
    * 对抛出的异常进行处理
    */
   @ControllerAdvice
   public class ExceptionHandle {
       private final static org.slf4j.Logger logger = LoggerFactory.getLogger(ExceptionHandle.class);
   
   	//该注解指出方法对哪类异常进行处理
       @ExceptionHandler(value = Exception.class)
       @ResponseBody
       public Result handle(Exception e){
           if(e instanceof GirlException){
               GirlException girlException = (GirlException) e;
               return ResultUtils.error(girlException.getCode(), girlException.getMessage());
           }else{
               logger.info("【系统错误】{}",e);
               return ResultUtils.error(-1, e.getMessage());
           }
       }
   }
   ```

## 单元测试

### 对Service进行测试

1. 右击方法，选择Go To→Test，会在test文件夹下生成一个service文件夹，里面有对应的测试类

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220210190627527.png" alt="image-20220210190627527" style="zoom:60%;" />

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220210190822710.png" alt="image-20220210190822710" style="zoom:80%;" />

2. 编写该测试类

   ```
   //测试显示no tests were found，找不出bug所在
   //在pom.xml中加入依赖，参考sell
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class GirlServiceTest {
       @Autowired
       private GirlService girlService;
   
       @Test
       public void findOne() throws Exception {
           Girl girl = girlService.findOne(4);
           Assert.assertEquals(new Integer(19),girl.getAge());
       }
   }
   ```

### 对Controller进行测试

1. 同Service，先创建测试类

2. 编写测试类

   ```
   //同上，感觉是依赖的问题
   @RunWith(SpringRunner.class)
   @SpringBootTest
   @AutoConfigureMockMvc
   public class GirlControllerTest {
       @Autowired
       private MockMvc mvc;
   
   	//检查测试路径
       @Test
       public void girlList() throws Exception {
           mvc.perform(MockMvcRequestBuilders.get("/girls"))
                   .andExpect(MockMvcResultMatchers.status().isOk())
                   .andExpect(MockMvcResultMatchers.content().string("abc"));
       }
   }
   ```


# 技术栈

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125174302973.png" alt="image-20220125174302973" style="zoom:80%;" />

# 环境&&版本号



<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220125174406080.png" alt="image-20220125174406080" style="zoom:80%;" />

# 项目设计

## 角色划分

![image-20220216143238559](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216143238559.png)

## 功能模块划分

![image-20220216143302762](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216143302762.png)

![image-20220216143330603](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216143330603.png)

## 部署架构

![image-20220216143353754](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216143353754.png)

## 数据库设计

![image-20220216143603227](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216143603227.png)

### 商品表

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216144452091.png" alt="image-20220216144452091" style="zoom:50%;" />

```
.sql文件编写注释：
	``反引号，英文输入法，波浪号下面的
	comment '引号内为注释内容'
    格式：create table `table_name`();
    prmary key(`id`)，指定主键
    unique key `uqe_category_type` (`category_type`),添加unique约束，键值唯一
    key `idx_buyer_openid` (`buyer_openid`),添加索引，前一个``中为索引名，后一个``中为索引值
```

```
create table `product_info` (
	`product_id` varchar(32) not null,
    `product_name` varchar(64) not null comment '商品名称',
    `product_price` decimal(8,2) not null comment '单价',
    `product_stock` int not null comment '库存',
	`product_description` varchar(64) comment '描述',
	`product_icon` varchar(512) comment '小图',
	`product_status` tinyint(3) DEFAULT '0' COMMENT '商品状态,0正常1下架',
	`category_type` int not null comment '类目编号',
	`create_time` timestamp not null default current_timestamp comment '创建时间',
	`update_time` timestamp not null default  current_timestamp 
		on update current_timestamp comment '更新时间',
	primary key (`product_id`)
) comment '商品表'
```

### 类目表

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216145827885.png" alt="image-20220216145827885" style="zoom:50%;" />

```
create table `product_category`(
	`category_id` int not null auto_increment,
	`category_name` varchar(64) not null comment '类目名称',
	`category_type` int not null comment '类目编号',
	`create_time` timestamp not null default current_timestamp comment '创建时间',
	`update_time` timestamp not null default  current_timestamp 
		on update current_timestamp comment '更新时间',
	primary key (`category_id`),
	unique key `uqe_category_type` (`category_type`)
)comment '类目表'
```

### 订单表

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216150709656.png" alt="image-20220216150709656" style="zoom:50%;" />

```
create table `order_master`(
	`order_id` varchar(32) not null,
	`buyer_name` varchar(64) not null comment '买家姓名',
	`buyer_phone` varchar(32) not null comment '买家电话',
	`buyer_address` varchar(128) not null comment '买家地址',
	`buyer_openid` varchar(64) not null comment '买家微信openid',
	`order_amount` decimal(8,2) not null comment '总金额',
	`order_status` tinyint(3) not null default '0' comment '订单状态,默认0新下单',
	`pay_status` tinyint(3)	not null default '0' comment '支付状态,默认0未支付',
	`create_time` timestamp not null default current_timestamp comment '创建时间',
	`update_time` timestamp not null default  current_timestamp 
		on update current_timestamp comment '更新时间',
	primary key(`order_id`),
	key `idx_buyer_openid` (`buyer_openid`)
)comment '订单表'
```

### 订单详情表

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216152031180.png" alt="image-20220216152031180" style="zoom:50%;" />

```
create table `order_detail`(
	`detail_id` varchar(32) not null,
	`order_id` varchar(32) not null comment '订单id',
	`product_id` varchar(32) not null comment '商品id', 
	`product_name` varchar(64) not null comment '商品名称',
	`product_price` decimal(8,2) not null comment '商品价格',
	`product_quantity` int not null comment '商品数量',
	`product_icon` varchar(512) comment '小图',
	`create_time` timestamp not null default current_timestamp comment '创建时间',
	`update_time` timestamp not null default  current_timestamp 
		on update current_timestamp comment '更新时间',
	primary key(`detail_id`),
	key `idx_order_id` (`order_id`)
) comment '订单详情表';
```

# 环境配置

1. 在VMware Workstation中导入准备好的虚拟机centos7.3，虚拟机中有以下软件：

   ```
   jdk 1.8.0_111
   nginx 1.11.7
   mysql 5.7.17
   redis 3.2.8
   ```

   ```
   jdk
   	路径 /usr/local/jdk1.8.0_111
   nginx
   	路径 /usr/local/nginx
   	启动 nginx
   	重启 nginx -s reload
   mysql
   	配置 /etc/my.conf
   	账号 root
   	密码 123456
   	端口 3306
   	启动 systemctl start mysqld
   	停止 systemctl stop mysqld
   redis
   	路径 /usr/local/redis
   	配置 /etc/reis.conf
   	端口 6379
   	密码 123456
   	启动 systemctl start redis
   	停止 systemctl stop redis
   tomcat
   	路径 /usr/local/tomcat
   	启动 systemctl start tomcat
   	停止 systemctl stop tomcat
   ```

   虚拟机账号密码：

   ```
   root
   123456
   ```

2. 在Navicat中新建一个连接，名为虚拟机，新街一个数据库，将上面写的.sql文件导入，建表成功。

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216165028200.png" alt="image-20220216165028200" style="zoom:60%;" /><img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216165927488.png" alt="image-20220216165927488" style="zoom:80%;" />

3. Windows下安装idea，maven等，前面都已经配置好了。
4. 新建一个项目，过程与创建第一个SpringBoot项目一样。

# 日志

## 日志框架的能力

- 定制输出目标
- 定制输出格式
- 携带上下文信息
- 运行时选择性输出
- 灵活的配置
- 优异的性能

## 常见的日志框架

![image-20220216185630379](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216185630379.png)

最优秀的框架：SLF4j + Logback

## 日志的使用

1. 使用对象

   ```
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class LoggerTest {
   	//创建Logger对象，其中的Logger是slf4包中的
       private final Logger logger = LoggerFactory.getLogger(LoggerTest.class);
   
       @Test
       public void test(){
           logger.info("info...");
           logger.debug("debug...");//默认级别为info，debug级别低于info，无法显示出来
           logger.error("error...");
       }
   }
   ```

2. 使用注解

   ```
   @RunWith(SpringRunner.class)
   @SpringBootTest
   @Slf4j      //替代对象实例化的注解
   public class LoggerTest {
   
       @Test
       public void test(){
       	//这里log报红线，因为idea没有安装lombok插件
           log.info("info..");
           log.error("error...");
       }
   }
   ```

3. 日志中输出对象

   ```
   @RunWith(SpringRunner.class)
   @SpringBootTest
   @Slf4j      //替代对象实例化的注解
   public class LoggerTest {
   
       @Test
       public void test(){
           String name = "little dust";
           String password = "123456";
           //两种Log.info()效果相同
           log.info("name: " + name + ", " + "password: " + password);
           //输出时可以使用{}作为占位符，在后面按顺序给出占位符代表的对象
           log.info("name: {}, password: {}", name , password);
       }
   }
   ```

## Logback的配置

1. application.yml

   - 区分info和error日志
   - 每天产生一个日志文件

   ```
   //编写yml数据库部分时，报错error creating bean with name 'entityManagerFactory'
   //解决方案，mysql的依赖版本设为5.1.48
   ```

   ```
   logging:
     pattern:
       # 输出格式为 "时间日期 - info中的信息"
       console: "%d - %msg%n"
   #  将日志内容输出到txt文件中，/var/log/tomcat/为文件地址,具体地址为E:\var\log\tomcat
     path: /var/log/tomcat
   #  file也是输出到文件，和path类似
     file: /var/log/tomcat/sell.log
   #  level可以指定日志级别，error、info、debug等，可以直接配置整个项目的日志级别，也可以指定特定的类的级别
     level:
       com.experience.LoggerTest: debug
   ```

2. logback-spring.xml

   1. 首先，resources-new-file，创建logback-spring.xml

   2. 编写xml文件

      ```
      <?xml version="1.0" encoding="UTF-8" ?>
      
      <configuration>
          <!--一个小的配置项，class="",需要引号内的类进行处理-->
          <!--默认级别是info，info以上级别默认输出，以下级别默认过滤-->
          <appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender">
              <layout class="ch.qos.logback.classic.PatternLayout">
                  <pattern>
                      %d - %msg%n
                  </pattern>
              </layout>
          </appender>
      
          <appender name="fileInfoLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
              <!--将error级别的日志过滤掉，非error级别的输出-->
              <filter class="ch.qos.logback.classic.filter.LevelFilter">
                  <level>ERROR</level>
                  <onMatch>DENY</onMatch>
                  <onMismatch>ACCEPT</onMismatch>
              </filter>
              <!--配置日志输出格式-->
              <encoder>
                  <pattern>
                      %d - %msg%n
                  </pattern>
              </encoder>
              <!--滚动策略-->
              <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                  <!--输出日志文件的路径，其中文件名中的%d为日期-->
                  <fileNamePattern>/var/log/tomcat/sell/info.%d.log</fileNamePattern>
              </rollingPolicy>
          </appender>
      
          <appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
              <!--将日志级别设为ERROR，error及以上可以输出，以下被过滤-->
              <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
                  <level>ERROR</level>
              </filter>
              <!--配置日志输出格式-->
              <encoder>
                  <pattern>
                      %d - %msg%n
                  </pattern>
              </encoder>
              <!--滚动策略-->
              <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                  <!--输出日志文件的路径，其中文件名中的%d为时间日期-->
                  <fileNamePattern>/var/log/tomcat/sell/error.%d.log</fileNamePattern>
              </rollingPolicy>
          </appender>
      
          <!--root代表整个项目，ref中填写上面配置项的name，将配置项配置到项目中-->
          <root level="info">
              <appender-ref ref="consoleLog"/>
              <appender-ref ref="fileInfoLog"/>
              <appender-ref ref="fileErrorLog"/>
          </root>
      </configuration>
      ```

# 三层架构

- dao层
- service层
- controller层

## dao层

以类目表为例：

1. pom.xml 引入依赖 

   ```
   <dependency>
   	<groupId>mysql</groupId>
   	<artifactId>mysql-connector-java</artifactId>
   	<version>5.1.48</version>
   </dependency>
   
   <dependency>
   	<groupId>org.springframework.boot</groupId>
   	<artifactId>spring-boot-starter-data-jpa</artifactId>
   </dependency>
   
   <!--用于lombok插件，@Data注解-->
   <dependency>
   	<groupId>org.projectlombok</groupId>
   	<artifactId>lombok</artifactId>
   </dependency>
   ```

2. application.yml配置文件

   ```
   spring:
   #  配置数据库连接
     datasource:
       driver-class-name: com.mysql.jdbc.Driver
   #    characterEncoding=utf-8配置，防止中文乱码
   #	mysql的URL在虚拟机中通过ifconfig查询虚拟机地址
       url: jdbc:mysql://192.168.1.4/sell?characterEncoding=utf-8&useSSL=false
       username: root
       password: 123456
   
     jpa:
       show-sql: true
   ```

3. 添加数据实体

   ```
   /**
    * 类目表
    * 类名单词首字母大写，数据库表名小写用_分隔，包名直接全小写
    */
   @Entity
   //@DynamicUpdate注解，可以自动的更新时间
   @DynamicUpdate
   //@Data注解，在lombok插件的帮助下，可以代替get(),set()方法
   @Data
   public class ProductCategory {
       @Id
       @GeneratedValue
       private Integer categoryId;//类目id,要和表中属性名保持一致
   
       private String categoryName;//类目名
   
       private Integer categoryType;//类目编号，unique key
   
       @Override
       public String toString() {
           return "ProductCategory{" +
                   "categoryId=" + categoryId +
                   ", categoryName='" + categoryName + '\'' +
                   ", categoryType=" + categoryType +
                   '}';
       }
   }
   ```

4. 添加操作数据库的repository

   ```
   /**
    * 该类对象可以对ProductCategory表进行处理
    */
   public interface ProductCategoryRepository extends JpaRepository<ProductCategory,Integer> {
   }
   ```

5. 添加单元测试

   ```
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class ProductCategoryRepositoryTest {
   
       @Autowired
       private ProductCategoryRepository productCategoryRepository;
   
       @Test
   //    @Transactional注解，不加会报错could not initialize proxy [com.experience.dataobject.ProductCategory#1] - no Session
   //    加了以后，test的操作不会改变数据库
       @Transactional
       public void findOneTest(){
           ProductCategory productCategory = productCategoryRepository.getOne(1);
           System.out.println(productCategory.toString());
           Assert.assertEquals(new Integer(1), productCategory.getCategoryType());
       }
   
       @Test
       @Transactional
       public void updateTest(){
           ProductCategory productCategory = productCategoryRepository.getOne(1);
           productCategory.setCategoryName("螺蛳粉");
           productCategoryRepository.save(productCategory);
           System.out.println(productCategory);
       }
   }
   ```

## service层

依旧以类目表对应的service为例

1. 创建service接口CategoryService

   ```
   /**
    * 类目服务
    */
   public interface CategoryService {
       //通过类目id查询某个类目项
       ProductCategory findOne(Integer categoryId);
   
       //查询表中所有类目
       List<ProductCategory> findAll();
   
       //通过类目的类型查询符合要求的类目项
       List<ProductCategory> findByCategoryTypeIn(List<Integer> categoryTypeList);
   
       //保存某类目到数据库
       ProductCategory save(ProductCategory productCategory);
   }
   ```

2. 创建Impl类实现该接口

   ```
   @Service
   public class CategoryServiceImpl implements CategoryService {
   
       @Autowired
       private ProductCategoryRepository repository;
   
       @Override
       public ProductCategory findOne(Integer categoryId) {
           return repository.getOne(categoryId);
       }
   
       @Override
       public List<ProductCategory> findAll() {
           return repository.findAll();
       }
   
       @Override
       public List<ProductCategory> findByCategoryTypeIn(List<Integer> categoryTypeList) {
           return repository.findByCategoryTypeIn(categoryTypeList);
       }
   
       @Override
       public ProductCategory save(ProductCategory productCategory) {
           return repository.save(productCategory);
       }
   }
   ```

3. 对接口实现类进行单元测试

   ```
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class CategoryServiceImplTest {
   
       @Autowired
       private CategoryServiceImpl categoryService;
   
       @Test
       @Transactional
       public void findOne() throws Exception {
           ProductCategory productCategory = categoryService.findOne(1);
           System.out.println(productCategory);
           Assert.assertEquals(new Integer(1),productCategory.getCategoryType());
       }
   
       @Test
       @Transactional
       public void findAll() throws Exception {
           List<ProductCategory> list = categoryService.findAll();
           Assert.assertNotEquals(0,list.size());
       }
   
       @Test
       @Transactional
       public void findByCategoryTypeIn() throws Exception {
           List<ProductCategory> list = categoryService.findByCategoryTypeIn(Arrays.asList(1, 2, 3, 4));
           Assert.assertNotEquals(0,list.size());
   
       }
   
       @Test
       @Transactional
       public void save() throws Exception {
           ProductCategory productCategory = categoryService.save(new ProductCategory("麻辣烫",2));
           Assert.assertNotEquals(null,productCategory);
           System.out.println(productCategory);
       }
   }
   ```

## controller层

1. 创建controller类，编写需要使用到的方法

   ```
   /**
    * 买家商品
    */
   @RestController
   //URL查看API文档中的说明
   @RequestMapping("/buyer/product")
   public class BuyerProductController {
   
       @Autowired
       private ProductServiceImpl productService;
   
       @Autowired
       private CategoryServiceImpl categoryService;
   
   
       @RequestMapping("/list")
       public ResultVO list(){
           //1.查询所有上架商品(从数据库中取）
           List<ProductInfo> productInfoList = productService.findUpAll();
   
           //2.查询类目（一次性查询）
           //传统方法
   //        List<Integer> categoryTypeList = new ArrayList<>();
   //        for(ProductInfo productInfo : productInfoList){
   //            categoryTypeList.add(productInfo.getCategoryType());
   //        }
   
           //精简方法(java8, lambda)
           List<Integer> categoryTypeList = productInfoList.stream()
                   .map(e -> e.getCategoryType())
                   .collect(Collectors.toList());
                   
           //获取productInfoList对应的商品中的类目信息
           List<ProductCategory> productCategoryList = categoryService.findByCategoryTypeIn(categoryTypeList);
   
           //3.数据拼装
   //        使用Util类避免代码重复
   //        ResultVO<List<ProductVO>> resultVO = new ResultVO<>();//最外层
   //        resultVO.setCode(0);
   //        resultVO.setMsg("成功");
   
           List<ProductVO> productVOList = new ArrayList<>(); //data体内列表
           for(ProductCategory productCategory : productCategoryList){
               //productVO，data里面的一层，name，type，foods
               ProductVO productVO = new ProductVO();
               productVO.setCategoryName(productCategory.getCategoryName());
               productVO.setCategoryType(productCategory.getCategoryType());
   
               //最里面一层，商品的部分信息
               List<ProductInfoVO> productInfoVOList = new ArrayList<>();
               for(ProductInfo productInfo : productInfoList){
                   if (productInfo.getCategoryType().equals(productCategory.getCategoryType())) {
                       ProductInfoVO productInfoVO = new ProductInfoVO();
   
                       //重复代码太多
   //                    productInfoVO.setProductId(productInfo.getProductId());
   //                    productInfoVO.setProductName(productInfo.getProductName());
   //                    productInfoVO.setProductPrice(productInfo.getProductPrice());
   //                    productInfoVO.setProductIcon(productInfo.getProductIcon());
   //                    productInfoVO.setProductDescription(productInfo.getProductDescription());
   
                       //使用该方法可以完成属性值的拷贝
                       BeanUtils.copyProperties(productInfo,productInfoVO);
   
                       productInfoVOList.add(productInfoVO);
                   }
               }
               productVO.setProductInfoVOList(productInfoVOList);
               productVOList.add(productVO);
           }
   
   		//由于每次设置返回对象的操作都相同，因此使用了ResultVOUtil工具类避免代码重复
           return ResultVOUtil.success(productVOList);
       }
   }
   ```

   ```
   public class ResultVOUtil {
       public static ResultVO success(Object object){
   
           ResultVO resultVO = new ResultVO();
           resultVO.setCode(0);
           resultVO.setMsg("成功");
           resultVO.setData(object);
   
           return resultVO;
       }
   
   
       public static ResultVO success() {
           return success(null);
       }
   
       public static ResultVO error(Integer code, String msg){
           ResultVO resultVO = new ResultVO();
           resultVO.setCode(code);
           resultVO.setMsg(msg);
           resultVO.setData(null);
           return resultVO;
       }
   }
   ```

2. 查询API文档，创建对应的返回类型类

![image-20220219201319083](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220219201319083.png)

```
@Data
public class ResultVO<T> {

    /** 错误码 */
    private Integer code;

    /** 提示信息 */
    private String msg;

    /** 具体内容,此处的泛型T可以是List类型 */
    private T data;

}
```

```
@Data
public class ProductVO {

    /** 类目名称 */
    @JsonProperty("name")
    private  String categoryName;

    /** 类目类型 */
    @JsonProperty("type")
    private Integer categoryType;

    /** 商品信息 */
    @JsonProperty("foods")
    private List<ProductInfoVO> productInfoVOList;
}
```

```
@Data
public class ProductInfoVO {

    @JsonProperty("id")
    private String productId;

    @JsonProperty("name")
    private String productName;

    @JsonProperty("price")
    private BigDecimal productPrice;

    @JsonProperty("description")
    private String productDescription;

    @JsonProperty("icon")
    private String productIcon;
}
```

3. 此时主机端口已经能正常访问，下一步需要和虚拟机建立连接

4. 修改centos配置文件

   1. ```
      vim /usr/local/nginx/conf/nginx.conf
      ```

   2. 将第47行的proxy_pass http://后的ip值改为主机ip

   3. 将36行的server_name 改为sell.com,代表以后通过sell.com访问主机

   4. 重启配置

      ```
      nginx -s reload
      ```

5. 修改主机配置文件

   编辑C:\Windows\System32\drivers\etc\hosts文件，最后一行添加

   ```
   192.168.1.8	sell.com # 将192.168.1.8的域名设为sell.com
   ```

   此时主机可以通过sell.com访问虚拟机，192.168.1.8为虚拟机的ip

6. 浏览器访问sell.com/#/,出现“请在微信客户端打开”，这是由cookies值为空造成的

   1. 先访问sell.com/#/order,F12，设置cookies值

      点击console，输入

      ```
      document.cookie='openid=abc' //abc为随意值，也可以使其他值
      ```

      然后查看cookies，发现不再为空（在application-cookies中查看）

   2. 再访问sell.com/#/，可正常访问

# 枚举类的使用

```
//Getter注解自动加入get()方法
@Getter
public enum  ProductStatusEnum {
    UP(0,"在售"),
    DOWN(1,"已下架")
    ;

    private Integer code;

    private String msg;

    ProductStatusEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }
}
```

```
//使用时直接调用
ProductStatusEnum.UP.getCode();//==0
```

# Page<>的使用

```
//返回类型为Page<>时，形参中必须有Pageable对象
Page<ProductInfo> findAll(Pageable pageable);

//调用时，new PageRequest(开始页号，每页容量)
PageRequest request = PageRequest.of(0, 2);
Page<ProductInfo> page = productService.findAll(request);
```

# API

```
使用类来进行统一的API管理,将API写成一个类，作为返回结果
将这些类放在VO包下，即view object，存放返回给前端的类
```

# Bug小结

- 进行单元测试时报错could not initialize proxy [com.experience.dataobject.ProductCategory#1] - no Session

  ```
  解决：方案1.在测试方法上添加@Transactional注解
  	 方案2.由于使用getOne()方法导致的，将getOne(id);换成findByid(id).orElse(null);
  ```

- 进行单元测试时报错：could not extract ResultSet

  ```
  原因：数据库中字段和实体类中字段不匹配，检查实体类的元素名称
  ```

- 进行单元测试时报错：ids for this class must be manually assigned before calling save(): com.experience.dataobject.OrderMaster;

  ```
  原因：OrderMaster的id值为空
  //出错代码
  OrderMaster orderMaster = new OrderMaster();
  orderMaster.setOrderId(orderId);
  orderMaster.setOrderAmount(orderAmount);
  BeanUtils.copyProperties(orderDTO,orderMaster);
  //BeanUtils.copyProperties(orderDTO,orderMaster)该操作会将上面设置的值覆盖掉，因此需要调整顺序，将该语句放在最前面
  ```

  ```
  注意：使用BeanUtils.copyProperties()方法时，注意值的覆盖问题
  ```

- Integer的比较大小问题

  ```
  // 当productInfo.getProductStock() == cartDTO.getProductQuantity()时，
  // productInfo.getProductStock() < cartDTO.getProductQuantity()为true
  // 但productInfo.getProductStock() > cartDTO.getProductQuantity()为false
  if(productInfo.getProductStock() < cartDTO.getProductQuantity()){
      throw new SellException(ResultEnum.PRODUCT_STOCK_ERROR);
  }
  ```

  ```
  // 赋值后再判断就能返回正确结果
  Integer result = productInfo.getProductStock() - cartDTO.getProductQuantity();
  if(result < 0){
  	throw new SellException(ResultEnum.PRODUCT_STOCK_ERROR);
  }
  ```

-  在进行前台音乐播放时，浏览器报错Uncaught (in promise) DOMException: play() failed because the user didn't interact with the document first.

  ```
  最新版的Chrome浏览器（以及所有以Chromium为内核的浏览器）中，已不再允许自动播放音频和视频，因此出现此错误，在创建订单之前，对页面进行一次操作即可，例如翻页等。
  ```

- 在Mybatis进行注入时，单元测试报错

  ```
  Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'serverEndpointExporter' defined in class path resource [com/experience/config/WebSocketConfig.class]: Invocation of init method failed; nested exception is java.lang.IllegalStateException: javax.websocket.server.ServerContainer not available
  ```

  ```
  经查阅资料，得知 SpringBootTest 在启动的时候不会启动服务器，所以 WebSocket 自然会报错，这个时候需要添加选项 webEnvironment，以便提供一个测试的 web 环境。
  @RunWith(SpringRunner.class)
  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  ```

  

# 项目包结构

- controller

  - BuyerProductController：买家购买商品的页面 http://sell.com/#/

    <img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220223172850758.png" alt="image-20220223172850758" style="zoom:30%;" />

- dataobject：存放数据库实体类的包
  - OrderDetail：订单详情表
  - OrderMaster：订单表
  - ProductCategory：类目表
  - ProductInfo：商品表
- dto：Data Transmission Object，存放用于前后端数据传输的类的包
  - CartDTO：购物车, productId + productQuantity，加减库存时使用
  - OrderDTO：订单，OrderMaster + List<OrderDetail>，创建订单时使用

- enums：存放枚举类的包

  - OrderStatusEnum
  - PayStatusEnum
  - ProductStatusEnum
  - ResultEnum：枚举抛出异常的code和msg

- exception：存放自定义的异常类的包

  - SellException：自定义异常类

- repository：存放数据库操作接口的包

  - OrderDetailRepository：自定义查询：List<OrderDetail> findByOrderId(String orderId);
  - OrderMasterRepository：Page<OrderMaster> findByBuyerOpenid(String buyerOpenid, Pageable pageable);
  - ProductCategoryRepository：List<ProductCategory> findByCategoryTypeIn(List<Integer> categoryTypeList);
  - ProductInfoRepository：List<ProductInfo> findByProductStatus(Integer productStatus);

- service：包下直接存放service接口，impl子包存放接口的实现类

  - impl

    - CategoryServiceImpl
    - OrderServiceImpl
    - ProductServiceImpl

  - CategoryService

    | CategoryService接口方法                                      |
    | ------------------------------------------------------------ |
    | ProductCategory findOne(Integer categoryId);      //通过类目id查询某个类目项 |
    | List<ProductCategory> findAll();     //查询表中所有类目      |
    | List<ProductCategory> findByCategoryTypeIn(List<Integer> categoryTypeList);    //根据类目名查询类目信息 |
    | ProductCategory save(ProductCategory productCategory);    //保存某类目到数据库 |

  - OrderService

    | OrderService接口方法                                         |
    | ------------------------------------------------------------ |
    | OrderDTO create(OrderDTO orderDTO);                          |
    | OrderDTO findOne(String orderId);                            |
    | Page<OrderDTO> findList(String buyerOpenId, Pageable pageable); |
    | OrderDTO cancel(OrderDTO orderDTO);                          |
    | OrderDTO finish(OrderDTO orderDTO);                          |
    | OrderDTO paid(OrderDTO orderDTO);                            |

  - ProductService

    | ProductService接口方法                         |
    | ---------------------------------------------- |
    | ProductInfo findOne(String productId);         |
    | List<ProductInfo> findUpAll();                 |
    | Page<ProductInfo> findAll(Pageable pageable);  |
    | ProductInfo save(ProductInfo productInfo);     |
    | void increaseStock(List<CartDTO> cartDTOList); |
    | void decreaseStock(List<CartDTO> cartDTOList); |

- utils：存放工具类的包
  - KeyUtil：可以随机生成唯一id，线程安全
  - ResultVOUtil：将对ResultVO对象的赋值操作封装在该工具类中，避免重复代码
- VO：Value Object存放交付给前端的类的包，完成API返回格式所需要的类,后端传给前端的
  - ProductInfoVO
  - ProductVO
  - ResultVO

- sellApplication：含有主方法的类

# 将Date转换成Long

1. Utils包下新建serializer包，包下新建类Date2LongSerializer

2. 写Date2LongSerializer类

   ```
   public class Date2LongSerializer extends JsonSerializer<Date> {
       @Override
       public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
           jsonGenerator.writeNumber(date.getTime() / 1000);
       }
   }
   ```

3. 可使用@JsonSerialize(using = Date2LongSerializer.class)注解，使得某个日期格式自动转换为Long

   ```
   @JsonSerialize(using = Date2LongSerializer.class)
   private Date createTime;
   ```

# 使值为null的对象在前端不显示

1. 若想要让某个类中的null值对象不显示，添加@JsonInclude(JsonInclude.Include.NON_NULL)注解即可

2. 若想要整个项目中的null值对象都不显示，在application.yml中配置如下：

   ```
   spring:
     jackson:
         default-property-inclusion: non_null
   ```

3. 若想要某个值为空时也显示，在类中为其添加默认值

# 微信网页授权

```
官方文档：https://mp.weixin.qq.com/wiki
调试：https://natapp.cn
第三方SDK:https://github.com/WeChat-Group/weixin-java-tools
```

1. 构造网页授权url

   首先构造网页授权url，然后构成超链接让用户点击：

   ```
   WxMpService wxMpService = ...;
   String url = ...;
   wxMpService.getOAuth2Service().buildAuthorizationUrl(url, WxConsts.OAuth2Scope.SNSAPI_USERINFO, null)
   ```

2. 获得access token

   当用户同意授权后，会回调所设置的url并把authorization code传过来，然后用这个code获得access token，其中也包含用户的openid等信息

   ```
   WxOAuth2AccessToken wxOAuth2AccessToken = wxMpService.getOAuth2Service().getAccessToken(code);
   ```

3. 获得用户基本信息

   ```
   WxMpUser wxMpUser = wxMpService.getOAuth2Service().getUserInfo(wxMpOAuth2AccessToken, null);
   ```

4. 刷新access token

   ```
   WxOAuth2AccessToken = wxMpService.getOAuth2Service().refreshAccessToken(wxOAuth2AccessToken.getRefreshToken());
   ```

5. 验证access token

   ```
   boolean valid = wxMpService.getOAuth2Service().validateAccessToken(wxOAuth2AccessToken);
   ```

# 发起微信支付

```
官方文档：https://pay.weixin.qq.com/wiki
第三方SDK：https://github.com/Pay-Group/best-pay-sdk
```

# fiddler设置代理

1. tools-options-connections,勾选Allow remote computers to connect。
2. 查看手机ip和电脑ip，ping一下确认可以ping通
3. 手机连接的WiFi设置代理
   1. 代理-手动
   2. 服务器主机名：192.168.1.8(主机ip)
   3. 服务器端口：与fiddler的connections里的端口保持一致，默认8888
   4. 其余不修改
4. 连接成功，可在fiddler上查看抓包信息。

# 模板渲染

1. 引入依赖

   ```
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-freemarker</artifactId>
   </dependency>
   ```

2. 需要渲染的方法，返回类型为ModelAndView，返回语句为

   ```
   return new ModelAndView("pay/create");//构造参数为.ftl文件的路径，当前路径是resources-templates-pay-create.ftl
   ```

3. 在new ModelAndView（）的形参对应的地址处编写.ftl文件，完成渲染模板的导入

4. 可以通过下面语句对渲染模板传值，其中map是在函数形参中的

   ```
   //这里传值是传入到create.ftl模板类中
    public ModelAndView list(@RequestParam("page") Integer page,
                             @RequestParam("size") Integer size,
                             Map<String,Object> map){
       map.put("payResponse", payResponse);
       return new ModelAndView("pay/create", map);
   }
   ```

5. 在.ftl文件中可以使用传入进来的值

   ```
   "appId":"${payResponse.appId}",     //公众号名称，由商户传入
   "timeStamp":"${payResponse.timeStamp}",         //时间戳，自1970年以来的秒数
   "nonceStr":"${payResponse.nonceStr}", //随机串
   "package":"${payResponse.packAge}",
   "signType":"MD5",         //微信签名方式：
   "paySign":"${payResponse.paySign}" //微信签名
   ```

# 套用前端模板

1. 访问http://www.ibootstrap.cn/，在这个网站设计自己的页面布局

2. 设计好后点击下载，可生成html代码，将其粘贴到项目HTML文件的body体内（.ftl也是html格式)

3. 根据下载弹窗中的提示，跳转到对应网站，复制对应版本的link，粘贴到<head><head>中。

   ![image-20220305175951024](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220305175951024.png)

4. 其余都按正常的html编写

![image-20220305180041919](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220305180041919.png)

# 实现翻页

1. 访问http://www.ibootstrap.cn/，获取翻页部分代码

2. 遍历页数

   1. 设置当前页为灰色
   2. 设置页面跳转

3. 设置上一页和下一页的跳转

   ```
   <#--分页-->
   <div class="col-md-12 column">
       <ul class="pagination pull-right">
           <#--若当前页面<=1，则上一页不能再进行跳转-->
           <#if currentPage lte 1>
               <li class="disable"><a href="#">上一页</a></li>
           <#--否则，跳转到当前页面-1-->
           <#else>
               <#--地址不加/则为相对路径，等价于下面的/sell/seller/order/list-->
               <li><a href="list?page=${currentPage-1}&size=${size}">上一页</a></li>
           </#if>
   
           <#--遍历第1页到第orderDTOPage.getTotalPages()页-->
           <#list 1..orderDTOPage.getTotalPages() as index>
               <#--将当前页设置为灰色-->
               <#if currentPage == index>
                   <li class="disabled"><a href="#">${index}</a></li>
               <#--其他页设置跳转链接-->
               <#else>
                   <li><a href="/sell/seller/order/list?page=${index}&size=${size}">${index}</a></li>
               </#if>
           </#list>
           <#--gte，>=-->
           <#if currentPage gte orderDTOPage.getTotalPages()>
               <li class="disable"><a href="#">下一页</a></li>
           <#else>
           <#--地址不加/则为相对路径，等价于下面的/sell/seller/order/list-->
               <li><a href="list?page=${currentPage+1}&size=${size}">下一页</a></li>
           </#if>
       </ul>
   </div>
   ```

# 实现修改模板不需要重启项目

```
build-build project
Ctrl + F9
```

# 接入Redis数据库

1. 下载Redis Deskstop Manager，输入名称和虚拟机url，密码为空，连接到虚拟机的Redis

2. idea project中引入依赖

   ```
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   ```

3. 在application.yml中进行配置

   ```
   spring:
     redis:
       host: 192.168.1.8
       port:6379
       //password: (此项目中没有配置密码)
   ```

4. 在需要使用到Redis的类中，引入StringRedisTemplate类对象

   ```
   @Autowired
   private StringRedisTemplate redisTemplate;
   ```

5. 调用该对象

   ```
   redisTemplate.opsForValue().set("avds", "sfde");
   ```

# 设置值到cookie

1. controller对应的方法中，要添加一个入参HttpServletResponse response

   ```
   public ModelAndView login(@RequestParam("openid")String openid,
                                 HttpServletResponse response){}
   ```

2. 向response里面写cookie

   ```
   Cookie cookie = new Cookie("token", token);
   cookie.setPath("/");
   cookie.setMaxAge(7200);
   response.addCookie(cookie);
   ```

   



