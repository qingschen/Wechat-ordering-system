# 1.项目设计

## 数据库设计

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220216143603227.png" alt="image-20220216143603227" style="zoom:50%;" />

建立数据库sql文件：sell.sql

```
-- 类目
create table `product_category` (
    `category_id` int not null auto_increment,
    `category_name` varchar(64) not null comment '类目名字',
    `category_type` int not null comment '类目编号',
    `create_time` timestamp not null default current_timestamp comment '创建时间',
    `update_time` timestamp not null default current_timestamp on update current_timestamp comment '修改时间',
    primary key (`category_id`)
);

-- 商品
create table `product_info` (
    `product_id` varchar(32) not null,
    `product_name` varchar(64) not null comment '商品名称',
    `product_price` decimal(8,2) not null comment '单价',
    `product_stock` int not null comment '库存',
    `product_description` varchar(64) comment '描述',
    `product_icon` varchar(512) comment '小图',
    `product_status` tinyint(3) DEFAULT '0' COMMENT '商品状态,0正常1下架',
    `category_type` int not null comment '类目编号',
    `create_time` timestamp not null default current_timestamp comment '创建时间',
    `update_time` timestamp not null default current_timestamp on update current_timestamp comment '修改时间',
    primary key (`product_id`)
);

-- 订单
create table `order_master` (
    `order_id` varchar(32) not null,
    `buyer_name` varchar(32) not null comment '买家名字',
    `buyer_phone` varchar(32) not null comment '买家电话',
    `buyer_address` varchar(128) not null comment '买家地址',
    `buyer_openid` varchar(64) not null comment '买家微信openid',
    `order_amount` decimal(8,2) not null comment '订单总金额',
    `order_status` tinyint(3) not null default '0' comment '订单状态, 默认为新下单',
    `pay_status` tinyint(3) not null default '0' comment '支付状态, 默认未支付',
    `create_time` timestamp not null default current_timestamp comment '创建时间',
    `update_time` timestamp not null default current_timestamp on update current_timestamp comment '修改时间',
    primary key (`order_id`),
    key `idx_buyer_openid` (`buyer_openid`)
);

-- 订单商品
create table `order_detail` (
    `detail_id` varchar(32) not null,
    `order_id` varchar(32) not null,
    `product_id` varchar(32) not null,
    `product_name` varchar(64) not null comment '商品名称',
    `product_price` decimal(8,2) not null comment '当前价格,单位分',
    `product_quantity` int not null comment '数量',
    `product_icon` varchar(512) comment '小图',
    `create_time` timestamp not null default current_timestamp comment '创建时间',
    `update_time` timestamp not null default current_timestamp on update current_timestamp comment '修改时间',
    primary key (`detail_id`),
    key `idx_order_id` (`order_id`)
);

-- 卖家(登录后台使用, 卖家登录之后可能直接采用微信扫码登录，不使用账号密码)
create table `seller_info` (
    `seller_id` varchar(32) not null,
    `username` varchar(32) not null,
    `password` varchar(32) not null,
    `openid` varchar(64) not null comment '微信openid',
    `create_time` timestamp not null default current_timestamp comment '创建时间',
    `update_time` timestamp not null default current_timestamp on update current_timestamp comment '修改时间',
    primary key (`seller_id`)
) comment '卖家信息表';
```



# 2.项目起步

## 搭建开发环境

安装虚拟机并配置(centos)

## 日志

1. resources下新建logback-spring.xml，进行Logback的配置

   ![image-20220226182419064](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220226182419064.png)

2. .xml内容如下：

   ```
   <configuration>
       <!--一个小的配置项，class="",需要引号内的类进行处理-->
       <!--默认级别是info，info以上级别默认输出，以下级别默认过滤-->
       <appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender">
           <layout class="ch.qos.logback.classic.PatternLayout">
               <pattern>
                   %d - %msg%n
               </pattern>
           </layout>
       </appender>
       
       <!--root代表整个项目，ref中填写上面配置项的name-->
       <root level="info">
           <appender-ref ref="consoleLog"/>
           <!--<appender-ref ref="fileInfoLog"/>-->
           <!--<appender-ref ref="fileErrorLog"/>-->
       </root>
   </configuration>
   ```

3. 在需要使用到日志的类中添加@Slf4注解，即可使用日志，日志格式为

   ```
   log.info("info");
   ```

# 3.卖家端类目

对应于类目表product_category

## JPA

1. 配置pom.xml文件

   ```
   <dependency>
   	<groupId>mysql</groupId>
   	<artifactId>mysql-connector-java</artifactId>
   	<version>5.1.48</version>
   </dependency>
   
   <dependency>
   	<groupId>org.springframework.boot</groupId>
   	<artifactId>spring-boot-starter-data-jpa</artifactId>
   </dependency>
   
   <!--用于lombok插件，@Data注解-->
   <dependency>
   	<groupId>org.projectlombok</groupId>
   	<artifactId>lombok</artifactId>
   </dependency>
   ```

2. 配置yml文件，接入数据库

   ```
   spring:
   #  配置数据库连接
     datasource:
       driver-class-name: com.mysql.jdbc.Driver
   #    characterEncoding=utf-8配置，防止中文乱码
   #	mysql的URL在虚拟机中通过ifconfig查询虚拟机地址
       url: jdbc:mysql://192.168.1.4/sell?characterEncoding=utf-8&useSSL=false
       username: root
       password: 123456
   
     jpa:
       show-sql: true
   ```

3. 创建dataobject包，该包存放实体类，包下创建ProductCategory实体类，实体类中的属性名和属性类型要和数据库表中的保持一致。如：product_id(varchar(32)) ->String productId

   ```
   //注解
   @Entity
   //@DynamicUpdate注解，可以自动的更新时间
   @DynamicUpdate
   //@Data注解，在lombok插件的帮助下，可以代替get(),set()方法
   @Data
   ```

4. 创建repository包，该包存放实体类的仓库类，在包下新建类ProductCategoryRepository类，对ProductCategory实体类进行操作

   ```
   public interface ProductCategoryRepository extends JpaRepository<ProductCategory,Integer> {
       //直接定义方法，idea会自动实现功能，注意方法名称必须和类名相对应
       List<ProductCategory> findByCategoryTypeIn(List<Integer> categoryTypeList);
   }
   ```

5. 为ProductCategoryRepository类添加单元测试，ProductCategoryRepository类中Ctrl+Alt+T，可以跳转到单元测试，新建单元测试类ProductCategoryRepositoryTest，进行测试。

   ```
   //在使用到某个类对象时，通过@Autowired进行注入
   @Autowired
   private ProductCategoryRepository repository;
   ```

### bug

1. 单元测试时，报错could not initialize proxy [com.experience.dataobject.ProductCategory#1] - no Session

   ```
   解决：1.百度使用@Transmission注解注解测试方法，该注解使得修改不写入数据库，不再报错，但会对测试结果有影响，有些错误的用例可以通过测试。
   	 2.后发现是由于repository.getOne(id)方法获取对象导致的，用repository.findById(id).orElse(nulll)替代即可
   ```

2. 单元测试时，报错could not extract ResultSet

   ```
   原因：数据库中字段和实体类中字段不匹配，检查实体类的元素名称
   解决：仔细检查数据库和实体类的各项名称及属性
   ```

## service

1. 创建service包，下面存放service接口和实现类，在service包下创建CategoryService接口，定义接口方法。

   ```
   public interface CategoryService {
       //通过类目id查询某个类目项
       ProductCategory findOne(Integer categoryId);
   
       //查询表中所有类目
       List<ProductCategory> findAll();
   
       /** 根据类目名查询类目信息 */
       List<ProductCategory> findByCategoryTypeIn(List<Integer> categoryTypeList);
   
       //保存某类目到数据库
       ProductCategory save(ProductCategory productCategory);
   }
   ```

2. service包下创建Impl包，存放service接口的实现类，创建CategoryServiceImpl类，实现接口方法，该类必须添加@Service注解。

3. 对CategoryServiceImpl类进行单元测试。

# 4.卖家端商品

## dao

1. dataobject包下编写实体类ProductInfo

2. repository包下编写实体类的仓库类接口ProductInfoRepository

   ```
   public interface ProductInfoRepository extends JpaRepository<ProductInfo,String> {
       /** 通过商品状态查询商品列表 */
       List<ProductInfo> findByProductStatus(Integer productStatus);
   }
   ```

3. 对ProductInfoRepository进行单元测试

## service

1. service包下创建ProductService接口，接口方法如下

   | ProductService接口方法                         |
   | ---------------------------------------------- |
   | ProductInfo findOne(String productId);         |
   | List<ProductInfo> findUpAll();                 |
   | Page<ProductInfo> findAll(Pageable pageable);  |
   | ProductInfo save(ProductInfo productInfo);     |
   | void increaseStock(List<CartDTO> cartDTOList); |
   | void decreaseStock(List<CartDTO> cartDTOList); |

2. service-impl包下创建接口实现类ProductServiceImpl，在进行减库存操作时，需要判断库存是否够减，引入异常类

3. enums包下创建ProductStatusEnum枚举类，枚举订单状态

4. 创建exception包用于存放异常类，包下创建SellException类，用于处理项目中的异常。异常类的实现：

   ```
   @Data
   public class SellException extends RuntimeException {
   
       private Integer code;
   
       public SellException(ResultEnum resultEnum) {
           super(resultEnum.getMsg());
           this.code = resultEnum.getCode();
       }
   
       public SellException(Integer code, String message) {
           super(message);
           this.code = code;
       }
   }
   ```

4. 创建enums包用于存放枚举类型，枚举类型中一般存放code和msg，通过枚举类使代码统一，在enums下创建ResultEnum枚举类型，用于枚举自定义异常类型

5. 在ProductServiceImpl类的decreaseStock方法中，判断库存不够减时，抛出异常

   ```
   if(result < 0){
   	throw new SellException(ResultEnum.PRODUCT_STOCK_ERROR);
   }
   ```

6. 对ProductServiceImpl类进行单元测试，其中Page<ProductInfo> findAll(Pageable pageable);方法参数是一个Pageable对象，通过以下方法生成：

   ```
   PageRequest request = PageRequest.of(0, 2);//第一个参数0是起始页数，第二个参数2是页面大小
   Page<ProductInfo> page = productService.findAll(request);//直接以request为参数
   ```

## controller

1. 创建controller包用于存放controller类，包下新建BuyerProductController类，用于实现商品web页面，类中实现方法

   ```
   @RequestMapping("/list")
   public ResultVO list(){
   	...
   }
   ```

2. 查看API中商品列表的URL，参数即返回参数

   1. URL为 /sell/buyer/product/list, /sell为整个项目都共有的路径，在.yml文件中进行配置

      ```
      #整个项目的URL前缀为/sell
      server:
        servlet:
          context-path: /sell
      ```

   2. /buyer/product为BuyerProductController类的路径在类名上方添加注解

      ```
      @RestController
      @RequestMapping("/buyer/product")
      public class BuyerProductController {
      	...
      }
      ```

   3. /list为方法路径，通过@RequestMapping("/list")注解实现

3. 查看API中商品列表的返回格式，确定函数的返回值

   1. 返回格式如下：

      ```
      {
          "code": 0,
          "msg": "成功",
          "data": [
              {
                  "name": "热榜",
                  "type": 1,
                  "foods": [
                      {
                          "id": "123456",
                          "name": "皮蛋粥",
                          "price": 1.2,
                          "description": "好吃的皮蛋粥",
                          "icon": "http://xxx.com",
                      }
                  ]
              },
              {
                  "name": "好吃的",
                  "type": 2,
                  "foods": [
                      {
                          "id": "123457",
                          "name": "慕斯蛋糕",
                          "price": 10.9,
                          "description": "美味爽口",
                          "icon": "http://xxx.com",
                      }
                  ]
              }
          ]
      }
      ```

   2. 创建VO包，用于存放返回给前端的类，包下创建ResultVO类，表示API中返回结果的最外层。即code(Integer),msg(String),data<T>,注意类中名称和API相对应。

      ```
      @Data
      public class ResultVO<T> {
      
          /** 错误码 */
          private Integer code;
      
          /** 提示信息 */
          private String msg;
      
          /** 具体内容,此处的泛型T可以是List类型 */
          private T data;
      
      }
      ```

   3. 在VO包下创建productVO，分析API可知，API最外层是一个上面创建的ResultVO类型，而data中泛型的内容为一个List，List内部的结构使用productVO来表示，即为name(String)，type(Integer)，foods(List)，可以直接属性名相对应，也可以通过@JsonProperty("name")注解实现对应。

      ```
      @Data
      public class ProductVO {
      
          /** 类目名称 */
          @JsonProperty("name")
          private  String categoryName;
      
          /** 类目类型 */
          @JsonProperty("type")
          private Integer categoryType;
      
          /** 商品信息 */
          @JsonProperty("foods")
          private List<ProductInfoVO> productInfoVOList;
      }
      ```

   4. 在VO包下创建ProductInfoVO，用于表示ProductIVO中foods列表中的具体内容。

4. 编写list()方法的具体实现，获取需要返回给前端的数据。在拼接数据时可以使用BeanUtils.copyProperties(productInfo,productInfoVO)方法，但注意该方法会将属性名相同的值进行完全覆盖，注意使用的顺序。

5. 创建utils包，用于存放需要使用到的工具类，工具类主要是为了避免代码重复。包下创建ResultVOUtil,用于将已经准备好的数据封装成对象，返回给前端。

   | ResultVOUtil                                                 |
   | ------------------------------------------------------------ |
   | public static ResultVO success(Object object){}  //Object -> ResultVO |
   | public static ResultVO success(){}  // Object = null         |
   | public static ResultVO error(Integer code, String msg){}     |

5. list()方法中调用ResultVOUtil.success(productVOList) 返回结果

6. 方法编写完成后，确认连接。

   1. 打开虚拟机，确认虚拟机的ip地址是否与.yml中的mysql填写的ip地址一致，不一致就修改

   2. 此时访问http://localhost:8080/sell/buyer/product/list，已经能够看到数据，下一步连接虚拟机中的前端

   3. 设置一个统一的域名用于访问虚拟机和主机

      1. 修改centos配置文件

         1. ```
            vim /usr/local/nginx/conf/nginx.conf
            ```

         2. 将第47行的proxy_pass http://后的ip值改为主机ip

         3. 将36行的server_name 改为sell.com,代表以后通过sell.com访问主机

         4. 重启配置

            ```
            nginx -s reload
            ```

      2. 修改主机配置文件

         编辑C:\Windows\System32\drivers\etc\hosts文件，最后一行添加

         ```
         192.168.1.8	sell.com # 将192.168.1.8的域名设为sell.com
         ```

         此时主机可以通过sell.com访问虚拟机，192.168.1.8为虚拟机的ip

   4. 此时可通过http://sell.com/sell/buyer/product/list访问页面

   5. 打开虚拟机中设置好的页面，访问网址http://sell.com/#/，第一次访问时，会出现“请在微信客户端打开”字段，这是由于cookies为空导致，进行如下设置：

      1. 先访问sell.com/#/order,F12，设置cookies值

         点击console，输入

         ```
         document.cookie='openid=abc' //abc为随意值，也可以使其他值
         ```

         然后查看cookies，发现不再为空（在application-cookies中查看）

      2. 再访问sell.com/#/，可正常访问

# 5.买家订单

## dao

1. dataobject包下创建OrderMaster类，对应订单表，OrderDetail类，对应订单详情表

   | OrderMaster属性 |      含义      |
   | :-------------: | :------------: |
   |     orderId     |     订单id     |
   |    buyerName    |    买家姓名    |
   |   buyerPhone    |    买家电话    |
   |  buyerAddress   |    买家地址    |
   |   buyerOpenid   | 买家微信openid |
   |   orderAmount   |     总金额     |
   |   orderStatus   |    订单状态    |
   |    payStatus    |    支付状态    |
   |   createTime    |    创建时间    |
   |   updateTime    |    更新时间    |

   | OrderDetail属性 |       含义       |
   | :-------------: | :--------------: |
   |    detailId     |    订单详情id    |
   |     orderId     |      订单id      |
   |    productId    |      商品id      |
   |   productName   |     商品名称     |
   |  productPrice   |     商品价格     |
   | productQuantity |     商品数量     |
   |   productIcon   | 商品图标（小图） |
   |   createTime    |     创建时间     |
   |   updateTime    |     更新时间     |

2. repository包下创建OrderMasterRepository接口和OrderDetailRepository接口，建立两个实体类的仓库类

3. 对两个repository接口进行单元测试

## service

1. service包下新建OrderService接口，实现方法如下

   | OrderService接口方法                                         |
   | ------------------------------------------------------------ |
   | OrderDTO create(OrderDTO orderDTO);                          |
   | OrderDTO findOne(String orderId);                            |
   | Page<OrderDTO> findList(String buyerOpenId, Pageable pageable); |
   | OrderDTO cancel(OrderDTO orderDTO);                          |
   | OrderDTO finish(OrderDTO orderDTO);                          |
   | OrderDTO paid(OrderDTO orderDTO);                            |

2. service-impl包下创建OrderServiceImpl接口实现类

3. 实现create（）方法

   1. 查看API，使得前后端对应

      1. 查看API创建订单，得到URL，接收参数和返回参数，返回类型依旧是ResultVO
      2. 分析接收参数，其中包含了OrderMaster的属性和OrderDetail中的属性，因此创建一个新的类用于接收这些信息。

      ```
      // 传递给后端的参数
      name: "张三"
      phone: "18868822111"
      address: "慕课网总部"
      openid: "ew3euwhd7sjw9diwkq" //用户的微信openid
      items: [{
          productId: "1423113435324",
          productQuantity: 2 //购买数量
      }]
      ```
      3. 创建dto包，包中存放用于接收前端传递过来的信息的类。包中新建类OrderDTO。orderDTO在OrderMaster的属性基础上，新增一个List<OrderDetail>。

      4. dto包下新建CartDTO类，用来存放前端传回数据的items中的productId和ProductQuantity。

   2. 要将订单存入数据库，必须补全OrderMaster类和OrderDetail类

      1. util包下新建KeyUtil，用于随机生成唯一的key，可以用于生成orderId和OrderDetailId
      2. enums下新建OrderStatusEnum类和PayStatusEnum类，用于枚举订单状态和支付状态
      3. OrderMaster类中金额通过传回的值计算，其他进行手动设置
      4. OrderDetail类中的缺失值通过ProductService查询出的ProductInfo进行赋值

   3. 补全后分别将OrderMaster类对象和OrderDetail类对象存入数据库

4. 实现findList()方法：

   ```
   创建converter包，用于存放类型转换的类，将一个类对象转换为另一个类对象，包下创建OrderMaster2OrderDTOConverter类，类中convert()方法实现将OrderMaste>转换成OrderDTO
   ```

   ```
   //使用lambda表达式实现list的转换
   //List<OrderMaster> -> List<OrderDTO>
   orderMasters.stream().map(e -> convert(e)).collect(Collectors.toList());
   ```

5. 实现其他方法，注意细节
6. 进行单元测试

## controller

1. controller包下创建BuyerOrderController类，实现了

   | BuyerOrderController                                         |
   | ------------------------------------------------------------ |
   | public ResultVO<Map<String,String>> create(@Valid OrderForm orderForm, BindingResult bindingResult){} |
   | public ResultVO<List<OrderDTO>> list(@RequestParam("openid") String openid,          @RequestParam(value = "page", defaultValue = "0")Integer page,      @RequestParam(value = "size", defaultValue = "10") Integer size){} |
   | public ResultVO<OrderDTO> detail(@RequestParam("openid") String openid, @RequestParam("orderId") String orderId){} |
   | public ResultVO cancel(@RequestParam("openid") String openid, @RequestParam("orderId") String orderId){} |

2. create方法实现

   1. 查看API，前端传回参数较多，新建form包，form下新建OrderForm类，用来存放前端传来的创建订单的数据。该类也算是实体类，只有属性，类头加上@Data方法，用于get和set属性值。每个属性可以设置下面的注解。

      ```
       @NotEmpty(message = "姓名必填")
       @JsonProperty("name")
       private String buyerName;
      ```

   2. create方法中需要有两个参数，一个是OrderForm,一个是BindingResult，并需要对BindingResult进行判断，判断其是否出错。

      ```
      @PostMapping("/create")
      public ResultVO<Map<String,String>> create(@Valid OrderForm orderForm, BindingResult bindingResult){
          if(bindingResult.hasErrors()){
              log.error("【创建订单】参数不正确,orderForm={}",orderForm);
              throw new SellException(ResultEnum.PARAM_ERROR.getCode(),
              						bindingResult.getFieldError().getDefaultMessage());
          }
          ...
      }
      ```

   3. converter包下新建OrderForm2OrderDTOConverter类，实现将OrderForm类对象转化为OrderDTOConverter类对象。

3. 在查看订单详情和取消订单时，要对传入的openid进行验证，验证其是否与orderId中对应的订单中的openid相对应，由于在controller尽可能的写逻辑业务，因此创建新的service类，BuyerService，并实现其方法，然后对其进行单元测试

   | BuyerService接口方法                                  |
   | ----------------------------------------------------- |
   | OrderDTO findOrderOne(String openid, String orderId); |
   | OrderDTO cancelOrder(String openid, String orderId);  |

4. 用postman进行测试，比对结果发现创建时间和更新时间的格式有问题，在utils包下新建serializer包，用于进行序列流的转换。包下新建Date2LongSerializer类

   ```
   public class Date2LongSerializer extends JsonSerializer<Date> {
       @Override
       public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
           jsonGenerator.writeNumber(date.getTime() / 1000);
       }
   }
   ```

5. 该类新建后，可通过@JsonSerialize(using = Date2LongSerializer.class)注解实现date到long的转换

   ```
   /** 创建时间. */
   @JsonSerialize(using = Date2LongSerializer.class)
   private Date createTime;
   ```

# 6.微信授权

## 前期准备

1. 获取一个外网IP：使用natapp

   ```
   natapp使用教程：https://natapp.cn/article/natapp_newbie
   ```

   ```
   natapp本地地址；C:\APP\natapp
   ```

   	1. 进入目录下，修改.ini文件中的authtoken
   	2. 双击.exe即可获取url

 2. 申请一个微信的测试公众号

    ```
    https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&t=sandbox/index
    ```

 3. 将页面中的网页授权用户基本信息，修改为当前url(去掉http://)

    ![image-20220301183528324](C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220301183528324.png)

## 获取openId

```
官方文档：https://mp.weixin.qq.com/wiki
调试：https://natapp.cn
第三方SDK:https://github.com/WeChat-Group/weixin-java-tools
```

1. 手工方式

2. 利用第三方SDK

   1. 查找GitHub网址，pom.xml中引入公众号相关依赖：

      ```
      <dependency>
          <groupId>com.github.binarywang</groupId>
          <artifactId>weixin-java-mp</artifactId>
          <version>4.2.0</version>
      </dependency>
      ```

   2. 查看API文档，在controller包下建立WeChatController

      1. 进行wxMpService的配置

         1. 新建config包，用于存放配置类，包下新建WechatMpConfig类，类中进行wxMPService的配置，配置步骤主要根据GitHub中的文档使用方法来进行。

            ```
            @Component
            public class WechatMpConfig {
            
                @Autowired
                private WechatAccountConfig wechatAccountConfig;
            
                //@Bean将注解的方法的返回值作为对象注入到容器中
                @Bean
                public WxMpService wxMpService(){
                    //创建一个WxMpService对象
                    WxMpService wxMpService = new WxMpServiceImpl();
                    //设置该对象的配置信息
                    wxMpService.setWxMpConfigStorage(wxMpConfigStorage());
                    return wxMpService;
                }
            
                @Bean
                public WxMpConfigStorage wxMpConfigStorage(){
                    // 设置APPId和APPSecret
                    WxMpDefaultConfigImpl wxMpConfigStorage = new WxMpDefaultConfigImpl();
                    wxMpConfigStorage.setAppId(wechatAccountConfig.getMpAppId());
                    wxMpConfigStorage.setSecret(wechatAccountConfig.getMpAppSecret());
                    return wxMpConfigStorage;
                }
            }
            ```

         2. 在.yml文件中配置mpAppId，mpAppSecret

            ```
            wechat:
              #公众号 APP_ID
              mpAppId:  wx4c2ffde5d09558ef
              mpAppSecret: 26849f78d44b686809616fe5146518c5
            ```

         3. config包下新建WechatAccountConfig类，用来注入.yml文件中对微信账号设置有关的配置，如mpAppId，mpAppSecret等.

      2. 在WeChatController中的authorize方法中调用sdk中的方法构造网页授权url

         ```
         String url = "http://sellproject.nat300.top/sell/wechat/userInfo";
         String redirectUrl = wxMpService.getOAuth2Service().buildAuthorizationUrl(url,
         WxConsts.OAuth2Scope.SNSAPI_BASE, URLEncoder.encode(returnUrl));
         ```

      3. 创建userInfo()获取access_token,在access_token获取openid

         ```
         @GetMapping("/userInfo")
         public String userInfo(@RequestParam("code") String code,
                              @RequestParam("state") String returnUrl) {
             //2.获取access_token,两个小时内有效
             WxOAuth2AccessToken wxOAuth2AccessToken = new WxOAuth2AccessToken();
             try{
                 wxOAuth2AccessToken = wxMpService.getOAuth2Service().getAccessToken(code);
         
             }catch (WxErrorException e){
                 log.error("【微信网页授权】{}",e);
                 throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(),e.getError().getErrorMsg());
             }
         
         
             String openId = wxOAuth2AccessToken.getOpenId();
             log.info("【微信网页授权】openid={}",openId);
         
             return "redirect:" + returnUrl + "?openid=" + openId;
         }
         ```

## 网页授权前端调试

1. 将前端界面完全导入，resources的static下新建api包，包内从资料包中拷入准备好的两个json文件。给ProductInfo找些适合的图片，填入数据库中。

2. 将之前设置的cookies清除，重新配置。

3. 配置虚拟机

   1. cd /opt/code/sell_fe_buyer/config

   2. vim index.js

   3. 更改build{}中的19,20行：

      ```
      sellUrl:'http://sell.com'
      openidUrl:'http://...(natapp中的网址)/sell/wechat/authorize'
      //若访问sell.com时，cookies中无openid，就会自动跳转到openidUrl中的地址，获取openid
      ```
   
   4. 保存后退出，cd..回到上一层目录，执行更改
   
      ```
      npm run build
      ```
   
   5. 继续在当前目录下，输入以下命令，进行拷贝：
   
      ```
      ls -al dist/
      cp -r dist/* /opt/data/wwwroot/sell/
      ```

4. 在微信中访问sell.com，会跳到authorize()获取openid，再跳转回sell.com

## bug

1. 微信端访问sell.com,为空

   ```
   1.手机成功的连接到了fiddler
   2.电脑端能打开
   3.手机能访问虚拟机地址
   ```

   ```
   尝试解决：
   	1.重连WiFi
   	2.重启隧道
   	3.重启虚拟机
   	4.重启项目
   	5.重装虚拟机！！！
   	6.开始想是不是access_token上限了，结果一看上限2000，明显不是
   	都没有用，气死个人
   ```

   ```
   最终解决办法：清理微信缓存
   ```

# 7.发起微信支付

## 创建预支付订单

1. controller包下新建PayController，编写create()方法，构造订单支付页面。订单支付主要分两步：

   1. 查询订单

      ```
      OrderDTO orderDTO = orderService.findOne(orderId);
      ```

   2. 订单支付

      1. 获取一个PayResponse对象

         ```
         //PayResponse对象属性
         private String prePayParams;
         private URI payUri;
         private String appId;
         private String timeStamp;
         private String nonceStr;
         @JsonProperty("package")
         private String packAge;
         private String signType;
         private String paySign;
         private Double orderAmount;
         private String orderId;
         private String outTradeNo;
         ```

      2. 可视化

      ```
      @GetMapping("/create")
      public ModelAndView create(@RequestParam("orderId") String orderId,
                         @RequestParam("returnUrl")String returnUrl,
                         Map<String, Object> map){
          //1.查询订单
          OrderDTO orderDTO = orderService.findOne(orderId);
      
          //2. 发起支付
          PayResponse payResponse = payService.create(orderDTO);
      
          map.put("payResponse", payResponse);
          map.put("returnUrl", returnUrl);
      
          return new ModelAndView("pay/create", map);
      }
      ```

2. service下新建PayService接口，完成支付相关的service，接口中先写一个create()方法，提供给PayController调用

3. service-impl下新建PayServiceImpl类，实现PayService中的create()抽象方法。

   ```
   @Service
   @Slf4j
   public class PayServiceImpl implements PayService{
   
       public static final String ORDER_NAME = "微信点餐订单";
   
       @Autowired
       private BestPayServiceImpl bestPayService;
   
       @Override
       public PayResponse create(OrderDTO orderDTO) {
           //新建PayRequest对象并设置其属性
           PayRequest payRequest = new PayRequest();
           payRequest.setOpenid(orderDTO.getBuyerOpenid());
           payRequest.setOrderAmount(orderDTO.getOrderAmount().doubleValue());
           payRequest.setOrderId(orderDTO.getOrderId());
           payRequest.setOrderName(ORDER_NAME);
           payRequest.setPayTypeEnum(BestPayTypeEnum.WXPAY_H5);
   
           log.info("【微信支付】request={}", JsonUtil.toJson(payRequest));
   
           //调用sdk中的类进行支付，返回PayResponse对象
           PayResponse payResponse = bestPayService.pay(payRequest);
   
           log.info("【微信支付】payResponse={}", JsonUtil.toJson(payResponse));
   
           return  payResponse;
   
       }
   }
   ```

4. 对PayServiceImpl类的create方法进行测试，将输出的request和PayRequest进行格式化，化为json格式，utils包下新建JSONUtil

   ```
   public class JsonUtil {
       public static String toJson(Object object) {
           GsonBuilder gsonBuilder = new GsonBuilder();
           gsonBuilder.setPrettyPrinting();
           Gson gson = gsonBuilder.create();
           return gson.toJson(object);
       }
   }
   ```

5. 在PayController的create()方法中进行PayRequest对象的设置时，需要用到BestPayService类对象，在config包下新建WeChatPayConfig配置类，对BestPayService类对象的属性进行配置。

## 在网页发起支付

1. 从微信官方开发文档中拷贝JSAPI调起支付相关代码，在resources-static包下新建一个pay.html存放该代码
2. 将该代码中的相关字段，改为create()中生成的PayRequest对象的字段值
3. 回到微信访问http://sellproject.nat300.top/sell/pay.html，可发起支付，该链接会短暂的弹出支付页面，但由于url未注册，会支付失败，原因是url确实没有注册orz...

## 动态注入参数发起支付

1. 引入依赖

   ```
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-freemarker</artifactId>
   </dependency>
   ```

2. 修改PayController中的返回参数，new一个ModelAndView对象，里面填入模板的路径

   ```
   //2. 发起支付
   return new ModelAndView("pay/create");
   ```

3. resources-templates内新建包pay（之前的pay.html无需再使用，可删除），pay下新建file：create.ftl，为需要使用的模板文件。

4. 修改PayController代码，将create.ftl应用上

   ```
   //2. 发起支付
   PayResponse payResponse = payService.create(orderDTO);
   
   //这里传值是传入到create.ftl模板类中
   map.put("payResponse", payResponse);
   map.put("returnUrl", returnUrl);
   
   return new ModelAndView("pay/create", map);//对应到templates-pay-create.ftl
   ```

5. 在create.ftl可以引用传入进来的参数进行赋值

   ```
   function onBridgeReady(){
       WeixinJSBridge.invoke(
               'getBrandWCPayRequest', {
                   "appId":"${payResponse.appId}",     //公众号名称，由商户传入
                   "timeStamp":"${payResponse.timeStamp}",         //时间戳，自1970年以来的秒数
                   "nonceStr":"${payResponse.nonceStr}", //随机串
                   "package":"${payResponse.packAge}",
                   "signType":"MD5",         //微信签名方式：
                   "paySign":"${payResponse.paySign}" //微信签名
               },
               function(res){
                   location.href = "${returnUrl}";
               }
       );
   }
   ...
   ```

6. 由于借用的是师兄的支付账号，因此通过以下网址访问：http://proxy.springboot.cn/pay?openid=oTg***&orderId=1646209378193421351&returnUrl=http://www.imooc.com，其中openid为自己的openid，订单号也是自己的订单号。

## 微信异步通知

接收异步通知支付结果 ，然后修改支付状态。

1. PayController中写notify()方法，接收异步通知

2. notify()的具体实现由service实现，service类下的PayService类中新建notify(),在PayServiceImpl中进行实现,通过调用sdk方法实现

   ```
   @Override
   public PayResponse notify(String notifyData) {
       PayResponse payResponse = bestPayService.asyncNotify(notifyData);
       log.info("【微信支付】异步通知，payResponse={}",JsonUtil.toJson(payResponse));
       return payResponse;
   }
   ```

3. 修改application.yml中的notify的url为当前url，即http://sellproject.nat300.top/sell/pay/notify

4. debug模式启动，微信下单，支付后，可以看到后台捕获到了notifyData

   ```
   <xml>
   <appid><![CDATA[wxd898fcb01713c658]]></appid>
   <bank_type><![CDATA[OTHERS]]></bank_type>
   <cash_fee><![CDATA[1]]></cash_fee>
   <fee_type><![CDATA[CNY]]></fee_type>
   <is_subscribe><![CDATA[Y]]></is_subscribe>
   <mch_id><![CDATA[1483469312]]></mch_id>
   <nonce_str><![CDATA[wv7xf8OWNsJCKris]]></nonce_str>
   <openid><![CDATA[oTg***************]]></openid>
   <out_trade_no><![CDATA[1646209378193421352]]></out_trade_no>
   <result_code><![CDATA[SUCCESS]]></result_code>
   <return_code><![CDATA[SUCCESS]]></return_code>
   # 微信传回的流水号，重要！！！
   <sign><![CDATA[DD815E4B314734311983540668876A5D]]></sign>
   <time_end><![CDATA[20220304174928]]></time_end>
   <total_fee>1</total_fee>
   <trade_type><![CDATA[JSAPI]]></trade_type>
   <transaction_id><![CDATA[4200001318202203043414596880]]></transaction_id>
   </xml>
   ```

5. 继续编写PayServiceImpl中的notify方法，接收到微信端返回的异步通知后，要从通知中获取信息，核对信息后修改支付状态。

   ```
   1.验证签名
   2.验证支付状态
   (1,2在sdk中已经完成验证)
   3.验证支付金额
   4.验证支付者
   ```

6. 验证支付金额时，对两个double类型的数进行比较，由于精度的问题，在utils下新建MathUtil类，处理两个double类型的比较。主要是将两个数相减，若精度小于某个值，就判他们相等。

7. 完成service的notify()后，在PayController中调用，并返回给微信处理结果，否则微信会一直向后端发送通知

   ```
   //返回给微信处理结果
   return new ModelAndView("pay/success");
   ```

## 微信退款

1. 在PayService接口中声明抽象方法refund()，在PayServiceImpl类中实现该方法，主要是调用接口中的refund方法，返回一个RefundResponse对象。
2. 对该方法进行单元测试
3. 在之前的OrderService中完善cancel()，方法中调用退款服务

## bug

1. 异步通知notify()函数中，调试时，报错“支付状态不正确”

   ```
   找了好久的bug，支付了无数笔订单，然后发现是异步通知一直在通知，一直调用notify，所以会报错，亏了一个亿呜呜呜，后来将处理的结果返回给微信后，微信端就不再推送了
   ```

# 8. 卖家订单

<img src="C:\Users\fj\AppData\Roaming\Typora\typora-user-images\image-20220305164114396.png" alt="image-20220305164114396" style="zoom:60%;" />

## dao层

1. 要用到的数据基本上前面已经实现了
2. 在OrderService中实现一个findList(Pageable pageable)，查询所有订单
3. 对该方法进行单元测试

## controller层

1. 创建SellerOrderController类

2. 类中创建list()方法，查询所有的订单项，并将orderDTOPage传入到渲染模板中

   1. resources-templates下新建包order，order下新建文件list.ftl

   2. 从http://www.ibootstrap.cn/中生成前端body，并写入list.ftl中，修改list.ftl中的表项，为所需要的值

   3. 运行项目，查看前端生成列表，列表中的订单状态和支付状态都是0和1，修改其为enums中的msg

      1. enums包下新建CodeEnum接口，定义一个getCode()方法；
      2. PayStatusEnum类和OrderStatus类都实现CodeEnum接口
      3. utils包下新建EnumUtil类，类中实现一个getByCode()方法，该返回一个泛型类

      ```
      public class EnumUtil {
      	//通过code和类名，返回对应的枚举类
          public static <T extends CodeEnum> T getByCode(Integer code, Class<T> enumClass){
              for(T each : enumClass.getEnumConstants()){
                  if(each.getCode().equals(code)){
                      return each;
                  }
              }
              return null;
          }
      }
      ```
   4. OrderDTO中实现getOrderStatusEnum()和getPayStatusEnum()，通过调用getByCode方法，可返回对应类型的枚举类

      ```
      //此注解可以让输出为Json格式时，忽略掉注解的方法
      @JsonIgnore
      public OrderStatusEnum getOrderStatusEnum(){
      	return EnumUtil.getByCode(orderStatus, OrderStatusEnum.class);
      }
      ```

   5. 在list.ftl中，通过调用orderDTO.getOrderStatusEnum().msg ，获得code对应的msg

   6. 编写前端页面，实现翻页效果。

3. 在SellerOrderController类中编写cancel(),实现/list页面的取消效果

   1. 通过orderId获得OrderDTO类对象，将该对象传给OrderService的cancel方法

   2. 若过程中出现错误，需要显示错误界面，在templates下新建包common，包下新建error.ftl和success.ftl，分别用于编写失败和成果情况下的前端模板。

   3. 编写两个.ftl文件，显示msg，并能够在三秒后跳转

      ```
      <#--实现三秒后跳转到url处-->
      <script>
          setTimeout('location.href="${url}"', 3000);
      </script>
      ```

   4. 将/cancel页面装入到/list页面的取消按钮中

      ```
      <td>
          <#if orderDTO.getOrderStatusEnum().msg != "已取消">
          	<a href="cancel?orderId=${orderDTO.orderId}">取消</a>
          </#if>
      </td>
      ```

4. 在SellerOrderController类中编写detail(),查看/list页面对应的订单详情。

## service层

直接调用OrderService。

# 9. 卖家端通用功能和上下架

## 实现边栏

1. 将准备好的(后端代码里)nav.ftl拷贝到templates-common包下

2. resources-static目录下新建css目录，将style.css拷贝进来

3. 在list.ftl中，通过下面语句将style引入

   ```
   <link rel="stylesheet" href="/sell/css/style.css">
   ```

4. 在list.ftl的body体内，将边栏加入

   ```
   <div id="wrapper" class="toggled">
       <#--边栏sidebar-->
       <#--include可以将后面路径中的模板引入，可ctrl+点击，看看能否点进去，点进去则路径正确-->
       <#include "../common/nav.ftl">
   
       <#--主要内容content-->
       <div id="page-content-wrapper">
       	<#--此处后面要加入list的内容，即之前写的表格之类的主体内容-->
       </div>
   </div>
   ```

5. 将之前写的主体内容，拷贝到主要内容的<div></div>体内。

6. 按照同样的方法，将标题也共用，抽出来header.ftl

7. 将标题加入list.ftl中，即将<head></head>的内容拷贝到header.ftl中，然后使用下列语句重新引入，代码复用

   ```
   <#--引入头部模板-->
   <#include "../common/header.ftl">
   ```

8. 同样的方法，将detail.ftl也加上边栏和标题

## 实现商品列表

1. 创建SellerProductController类，实现其list()方法，实现方法和SellerOrderController方法十分类似。

2. templates下创建product包，包下创建list.ftl，编写该模板，其中使用到了图片的引入

   ```
   <td><img height="100" width="100" src="${productInfo.productIcon}" alt=""></td>
   ```

3. 在获取productInfo属性时，将createTime和updateTime属性加入到ProductInfo类中，并添加@DynamicUpdate注解

4. 在获取productInfo的上下架信息时，依旧需要EnumUtil的getByCode方法，即需要在ProductInfo类中创建getProductStatusEnum()方法。

   ```
   此处虽然ProductInfo是实体类，但使用@JSONIgnore注解getProductStatusEnum()后，并不会报错。
   ```

## 商品上下架

1. 在ProductService接口中新增上架和下架方法(onSale()和offSale())，并在ProductServiceImpl中实现这两个方法
2. 在SellerProductController类中使用ProductServiceImpl的方法完成上架和下架功能。

# 10. 卖家端新增商品和类目

## 新增修改页面

1. 创建index()函数实现新增修改页面，点击修改按钮跳转到该页面，该页面的输入框中存的是原来的ProductInfo值
2. 入参为productInfo和map，向模板中传入productInfo和categoryList
3. 创建并编写templates-product包下的index.ftl，其中涉及大量的前端知识

## 修改表单提交

1. /index界面点击提交按钮后，将跳转到提交界面，在SellerProductController中新建save(),将前端修改的值保存起来
2. 新建ProductForm类，用于保存前端修改的值，类中属性和前端label属性保持一致
3. save()入参为productForm，bindingResult和map
   1. 判断bindingResult，若出错则返回erro模板
   2. 根据productForm的productId，从数据库中查找productInfo
   3. 将productForm中的值赋给productInfo
   4. 保存productInfo到数据库中
4. 出错装入error模板，正确装入success模板

## 新增功能

1. 在index()中，添加一个if else语句，若是新增商品信息，则要生成一个productId
2. 在productInfo类中，为productStatus设置一个默认值，默认为上架

## 卖家类目功能开发

步骤与卖家端商品基本相同，比其简单。

# 11. 买家端与卖家端的连通

## 分布式系统

### 特点

- 多节点
- 消息通信
- 不共享内存

### 分布式系统 vs 集群

- 分布式系统强调不同功能的节点，集群强调同一功能的节点
- 分布式可以类比为一群炒菜的和一群洗菜的，集群类比为一群炒菜的
- 分布式可以使用集群，集群不一定是分布式的。

### session

可以看成一个key-value机制。

## 卖家登录功能

### dao

1. 数据库中新建seller_info表,用于存放卖家信息
2. 创建对应的实体类，dataobject包下新建SellerInfo类
3. 创建对应的repository，repository包下新建SellerInfoRepository
4. 对SellerInfoRepository进行测试

### sevice

1. service下新建SellerService接口，实现通过openid查询卖家讯息。
2. impl包下新建SellerServiceImpl实现接口。
3. 进行单元测试看是否正确。

### 卖家扫码登录获取openid

```
官方文档：https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html
```

1. application.yml中填入openAPPId和openAPPSecret

2. 在config包下的WechatAccountConfig类中添加openAPPId和openAPPSecret两个属性

3. 在config包下新建WeChatOpenConfig类，配置开放平台属性，设置方法和WeChatMPConfig基本一致。

   ```
   注意：在第三方SDK中，调用的方法仍是WxMpService，mp...
   ```

4. 在WechatController中写入方法qrAuthorize(),qrUserInfo(),和mp的方法很类似。

5. 使用以下网址进行测试（因为是借用的网址），扫码即可登录成功

   ```
   https://open.weixin.qq.com/connect/qrconnect?appid=wx6ad144e54af67d87&redirect_uri=http%3A%2F%2Fsell.springboot.cn%2Fsell%2Fqr%2FoTg***&response_type=code&scope=snsapi_login&state=http%3A%2F%2Fsellproject.nat300.top%2Fsell%2Fwechat%2FqrUserInfo
   ```

6. config包下创建一个ProjectUrlConfig，配置一下各项url，其中注解为

   ```
   @Data
   @ConfigurationProperties(prefix = "projecturl")
   @Component
   ```

7. 在application.yml中同步修改配置

### 卖家登录

1. 创建SellerUserController类，编写登录登出页面

2. 编写函数login()

   1. openid去和数据库里的数据匹配

   2. 设置token至Redis

      ```
      String token = UUID.randomUUID().toString();
      Integer expire = RedisConstant.EXPIRE;
      //Redis一定要设置过期时间，redisTemplate在上面引入的
      //@Autowired
      //private StringRedisTemplate redisTemplate;
      redisTemplate.opsForValue().set(String.format(RedisConstant.TOKEN_PREFIX,token),
      				openid,expire, TimeUnit.SECONDS);
      ```

   3. 设置token值cookie

      1. utils包下新建一个CookieUtil，类中设置set()方法，用于写入cookie
   
         ```
         public static void set(HttpServletResponse response,String name,String value,int maxAge){
             Cookie cookie = new Cookie(name, value);
             cookie.setPath("/");
             cookie.setMaxAge(maxAge);
             response.addCookie(cookie);
         }
         ```
      
      2. login()中调用CookieUtil.set(),定义constant-CookieConstant，保存和cookie相关的常量
      
      3. 访问http://sellproject.nat300.top/sell/seller/login?openid=oTg***进行测试。
      
   4. 设置返回值，直接跳转到已有页面，使用“redirect”关键字，地址跳转时，最好使用绝对地址，而不是相对地址
   
      ```
      return new ModelAndView("redirect:" + projectUrlConfig.getSell() + "/sell/seller/order/list");
      ```

### 卖家登出

在SellerUserController类中编写logout()函数：

1. 从cookie中查询，在CookieUtil类中新建get()方法实现查询

   ```
   public static Cookie get(HttpServletRequest request,String name){
       Map<String, Cookie> cookieMap = readCookieMap(request);
       return cookieMap.getOrDefault(name,null);
   }
   
   /**
    * 查出的cookie数组转化为map
    * @param request
    * @return
    */
   private static Map<String,Cookie> readCookieMap(HttpServletRequest request){
       Map<String, Cookie> cookieMap = new HashMap<>();
       Cookie[] cookies = request.getCookies();
       if(cookies != null){
           for(Cookie cookie : cookies){
               cookieMap.put(cookie.getName(), cookie);
           }
       }
       return  cookieMap;
   }
   ```

2. logout()中调用get方法，判断查到的cookie是否为空，若不为空，则将cookie从Redis中清除

   ```
   redisTemplate.opsForValue().getOperations().delete(String.format(RedisConstant.TOKEN_PREFIX, cookie.getValue()));
   ```

3. 再将cookie清除

   ```
   CookieUtil.set(response,CookieConstant.TOKEN, null, 0);
   ```

4. 返回结果模板，通过http://sellproject.nat300.top/sell/seller/logout进行测试。

### AOP实现身份验证

1. 新建aspect包，用于存放切面类。包下新建SellerAuthorizeAspect类。

2. 定义切点，Seller*类都需要验证身份（除SellerUserController类，该类本就用于身份验证）

   ```
   @Pointcut("execution(public * com.experience.controller.Seller*.*(..))" +
           "&& !execution(public * com.experience.controller.SellerUserController.*(..))")
   public void verify() {
   
   }
   ```

3. 进行身份验证

   1. 需要在切点之前验证，使用before注解

   2. 获取request

      ```
      ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
      HttpServletRequest request = attributes.getRequest();
      ```

   3. 查询cookie

      1. 查询

         ```
         //查询cookie
         Cookie cookie = CookieUtil.get(request, CookieConstant.TOKEN);
         ```

      2. 此处新建了一个异常类SellerAuthorizeException，类中没有内容，需要使用类名做登录失败的处理

         ```
         public class SellerAuthorizeException extends RuntimeException {}
         ```

      3. 新建handler包，包下存放异常处理类，新建SellerExceptionHandler类，处理SellerAuthorizeException异常。

         ```
         @ControllerAdvice
         public class SellerExceptionHandler {
         
             @Autowired
             private ProjectUrlConfig projectUrlConfig;
         
             /**
              * 若发生登录异常，即用户未登录，就跳转到用户登录界面进行登录操作
              * @return
              */
             @ExceptionHandler(value = SellerAuthorizeException.class)
             public ModelAndView handlerAuthorizeException(){
         
                 //TODO 微信扫码登录地址
                 return new ModelAndView("redirect:"
                         .concat(projectUrlConfig.getSell())
                         .concat("/sell/seller/login")
                         .concat("?openid=oTg***"));
             }
         }
         ```

      4. 若cookie为空，抛出异常SellerAuthorizeException

         ```
         if(cookie == null){
             log.warn("【登录校验】Cookie中查不到token");
             //SellerAuthorizeException里面什么方法和属性都没有
             throw new SellerAuthorizeException();
         }
         ```

   4. 在Redis中查询用户

      ```
      //Redis中查询
      String tokenValue = redisTemplate.opsForValue()
              .get(String.format(RedisConstant.TOKEN_PREFIX, cookie.getValue()));
      
      if (StringUtils.isEmpty(tokenValue)) {
          log.warn("【登录校验】Redis中查不到token");
          throw new SellerAuthorizeException();
      }
      ```

## 微信模板消息推送

```
查看相关文档后，通过SDK完成。
```

1. 创建PushMessageService类，定义抽象方法

   ```
   void orderStatus(OrderDTO orderDTO);
   ```

2. 创建PushMessageServiceImpl类，实现该方法，主要是调用sdk对消息进行赋值

   ```
   @Override
   public void orderStatus(OrderDTO orderDTO) {
   	WxMpTemplateMessage templateMessage = new WxMpTemplateMessage();
   	//调用WechatAccountConfig中的配置项来获取templateId
   	templateMessage.setTemplateId(accountConfig.getTemplateId().get("orderStatus"));
   	//获取用户的openid
   	templateMessage.setToUser(orderDTO.getBuyerOpenid());
   
   	List<WxMpTemplateData> data = Arrays.asList(
   			new WxMpTemplateData("first", "亲，请记得收货。"),
   			new WxMpTemplateData("keyword1", "微信点餐"),
   			new WxMpTemplateData("keyword2", "18868812345"),
   			new WxMpTemplateData("keyword3", orderDTO.getOrderId()),
   			new WxMpTemplateData("keyword4", orderDTO.getOrderStatusEnum().getMessage()),
   			new WxMpTemplateData("keyword5", "￥" + orderDTO.getOrderAmount()),
   			new WxMpTemplateData("remark", "欢迎再次光临！")
   	);
   	templateMessage.setData(data);
   	try {
   		wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage);
   	}catch (WxErrorException e) {
   		//这里并未对异常进行具体的处理，因为消息推送不是至关重要的模块
   		log.error("【微信模版消息】发送失败, {}", e);
   	}
   }
   ```

3. application.yml中添加templateId配置，并在WechatAccountConfig获取配置

   ```
   private Map<String,String> templateId;
   ```

4. 在OrderServiceImpl的finish方法的return语句之前，调用微信模板消息推送

   ```
   pushMessageService.orderStatus(orderDTO);
   ```

## webSocket消息推送

1. 编写模板类，templates-order-list.ftl,在<body></body>体内编写webSocket代码

   ```
   <script>
       var websocket = null;
   
       if('webSocket' in window){
       	websocket = new WebSocket('ws://sellproject.nat300.top/sell/webSocket');
       }else{
           alert('该浏览器不支持websocket！');
       }
   
       websocket.onopen = function (event) {
           console.log('建立连接');
       }
   
       websocket.onclose = function (event) {
           console.log('连接关闭');
       }
   
       websocket.onmessage = function (event) {
           console.log('收到消息：' + event.data);
           //弹窗提醒，播放音乐等处理
       }
   
       websocket.onerror = function (event) {
           console.log('websocket发生错误！');
       }
   
       websocket.onbeforeunload = function (event) {
           websocket.close();
       }
   </script>
   ```

2. 编写后端支持

   1. 在pom.xml中引入依赖

      ```
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-websocket</artifactId>
      </dependency>
      ```

   2. 创建一个配置类WebSocketConfig

      ```
      @Component
      public class WebSocketConfig {
          
          @Bean
          public ServerEndpointExporter serverEndpointExporter(){
              return new ServerEndpointExporter();
          }
      }
      ```

   3. 编写功能类WebSocket，由于其不是controller，也不能算是service，放在service包下，但使用的注解并非@Service

      ```
      @Component
      @ServerEndpoint("/webSocket")
      @Slf4j
      public class WebSocket {
      
          private Session session;
      
          private static CopyOnWriteArraySet<WebSocket> webSocketSet = new CopyOnWriteArraySet<>();
      
          @OnOpen
          public void onOpen(Session session){
              this.session = session;
              webSocketSet.add(this);
              log.info("【websocket消息】有新的连接，总数：{}",webSocketSet.size());
          }
      
          @OnClose
          public void onClose(){
              webSocketSet.remove(this);
              log.info("【websocket消息】连接断开，总数：{}",webSocketSet.size());
      
          }
      
          @OnMessage
          public void onMessage(String message){
              log.info("【websocket消息】收到客户端发来的消息：{}",message);
          }
      
      
          public void sendMessage(String message){
              for(WebSocket webSocket : webSocketSet){
                  log.info("【websocket消息】广播消息，message={}",message);
                  try {
                      //给前端传送消息
                      webSocket.session.getBasicRemote().sendText(message);
                  } catch (IOException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
      ```

   4. 访问http://sellproject.nat300.top/sell/seller/order/list，控制台会输出连接结果。

   5. 在OrderServiceImpl类中引入WebSocket对象，然后在create方法返回结果前，调用sendMessage方法，向客户端传递消息。

      ```
      //发送websocket消息
      webSocket.sendMessage("有新的订单");
      ```

   6. 使用postman创建订单，测试浏览器能否接收到消息。Fn+F12,Console，可以看到服务器端的消息传送过来了。
   
   7. 为前端配置弹窗，音乐等，修改list.ftl
   
   8. 进行测试

# 12. 项目优化

## 异常处理

对项目中的SellException异常类进行处理，使得前端返回格式为ResultVO

1. 在SellerExceptionHandler类中新建handlerSellException方法，用于处理ResultVO类

   ```
   @ExceptionHandler(value = SellException.class)
   @ResponseBody
   public ResultVO handlerSellException(SellException e){
       return ResultVOUtil.error(e.getCode(), e.getMessage());
   }
   ```

2. 此时前端返回的已经为ResultVO格式，即符合API，若想要改变返回的status，可使用@ResponseStatus注解

   ```
   @ResponseStatus(HttpStatus.CONTINUE)
   ```

## Mybatis

### 注解方式

1. 引入依赖

   ```
   <dependency>
       <groupId>org.mybatis.spring.boot</groupId>
       <artifactId>mybatis-spring-boot-starter</artifactId>
       <version>1.2.0</version>
   </dependency>
   ```

2. 在dataobject下新建包mapper，以ProductCategory类为例，用mybatis对该类进行增删改查

3. 将该包作为mybatis的注入路径，通过注解的形式添加到主类SellApplication中

   ```
   @MapperScan(basePackages = "com.experience.dataobject.mapper")
   ```

4. mapper包下新建ProductCategoryMapper接口，定义增删改查方法

   1. 插入

      1. 编写插入接口

         ```
         public interface ProductCategoryMapper {
         
             /**
              * @Insert 注解内的语句为mysql语句
              * values()中的值从map中取
              * 使用#{key,jdbcType=type}获取map中键为key的值
              * @return 若正确插入，返回1，否则返回0
              */
             @Insert("insert into product_category(category_name, category_type) values(#{category_name,jdbcType=VARCHAR}, #{category_type,jdbcType=INTEGER})")
             int insertByMap(Map<String, Object> map);
         
         }
         ```

      2. 对该insert方法进行测试，注意进行测试时，测试类的注解要如下，搭建一个网络环境，否则会报错

         ```
         @RunWith(SpringRunner.class)
         @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
         ```

         ```
         @Test
         public void insertByMap() throws Exception {
             Map<String, Object> map = new HashMap<>();
             map.put("category_name", "热销榜");
             map.put("category_type", 4);
             int result = mapper.insertByMap(map);
             Assert.assertEquals(1,result);
         }
         ```

      3. 也可通过对象来进行插入，即函数的入参为对象类型，更为常用

         ```
         @Insert("insert into product_category(category_name, category_type) values(#{categoryName,jdbcType=VARCHAR}, #{categoryType,jdbcType=INTEGER})")
         
         int insertByObject(ProductCategory productCategory);
         ```

   2. 查询

      ```
      /**
       * @Select 注解中写select语句，#{attribute}中的attribute与函数形参保持一致
       * @Results 该注解可以理解成一个数组
       * @Result 将数据库中的值映射到ProductCategory中，使得返回结果为ProductCategory对象
       * 若查出的结果不唯一，返回类型要为list
       * @param categoryType
       * @return
       */
      @Select("select * from product_category where category_type = #{categoryType}")
      @Results({
              @Result(column = "category_id", property = "categoryId"),
              @Result(column = "category_name", property = "categoryName"),
              @Result(column = "category_type", property = "categoryType")
      })
      ProductCategory findByCategoryType(Integer categoryType);
      ```

   3. 更新

      ```
      /**
       * 通过某字段进行更新
       * 在传多个参数时，要使用@param注解
       * 若categoryType对应多个值，则都会进行更新，返回更新的记录数
       * @param categoryName
       * @param categoryType
       * @return
       */
      @Update("update product_category set category_name=#{categoryName} where category_type = #{categoryType}")
      int updateByCategoryType(@Param("categoryName") String categoryName,@Param("categoryType") Integer categoryType);
      ```

   4. 删除

      ```
      @Delete("delete from product_category where category_type = #{categoryType}")
      int deleteByCategoryType(Integer categoryType);
      ```

5. 将mapper应用到项目中，在mapper同级目录下，本项目中为dataobject下，新建dao包，包下新建ProductCategoryDao类，在该类中引入ProductCategoryMapper类，并将该类中的方法封装。

   ```
   public class ProductCategoryDao {
       
       @Autowired
       private ProductCategoryMapper mapper;
       
       public int insert(ProductCategory productCategory){
           return mapper.insertByObject(productCategory);    
       }
   }
   ```

6. 当在service中要使用到的时候，就注入ProductCategoryDao类对象，进行数据库的增删改查

7. 想要日志中输出sql语句，可以对application.yml进行配置

   ```
   logging:
     level: 
   #    Mapper类所在的包名
       com.experience.dataobject.mapper: trace
   ```

### xml方式

1. 引入依赖

2. 新建mapper包，新建Mapper接口类

3. 配置SellApplication类注解，完成注入（前三步和注解方式相同）

4. 在ProductCategoryMapper接口中进行方法的声明，此时无需加入注解

   ```
   ProductCategory selectByCategoryType(Integer categoryType);
   ```

2. resources下新建mapper包，包下新建ProductCategoryMapper.xml，用于配置ProductCategoryMapper

   ```
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
   <!--mapper文件所在路径-->
   <mapper namespace="com.experience.dataobject.mapper.ProductCategoryMapper" >
   
       <!--查询结果到对象的映射-->
       <resultMap id="BaseResultMap" type="com.experience.dataobject.ProductCategory">
           <id column="category_id" property="categoryId" jdbcType="INTEGER" />
           <id column="category_name" property="categoryName" jdbcType="VARCHAR" />
           <id column="category_type" property="categoryType" jdbcType="INTEGER" />
       </resultMap>
   
       <!--查询语句-->
       <select id="selectByCategoryType" resultMap="BaseResultMap" parameterType="java.lang.Integer">
           select category_id, category_name, category_type
           from product_category
           where category_type = #{category_type, jdbcType=INTEGER}
       </select>
   </mapper>
   ```

3. 在application.yml中进行配置

   ```
   mybatis:
     mapper-locations: classpath:mapper/*.xml
   ```

4. 进行单元测试

## 分布式锁
1. 从已有代码中拷贝SecKillService，SecKillServiceImpl，SecKillController，RedisLock
2. 访问http://127.0.0.1/sell/skill/order/123456进行测试，每刷新一次，数量--
3. 对网站进行压力测试，ab -n 500 -c 100 http://127.0.0.1/sell/skill/order/123456，此时商品成功下单用户数目+剩余数目 > 10000
4. 解决方法：
	1. 使用synchronized关键字修饰方法，可以达到效果，但是压测速度很慢
		1. 无法做到细粒度控制
		2. 只适合单点的情况，集群不可以使用
	2. Redis分布式锁
		1. 上锁
			```
			    /**
				 * 加锁
				 * @param key
				 * @param value 当前时间+超时时间
				 * @return
				 */
				public boolean lock(String key, String value) {
			        // setIfAbsent()方法即Redis中的setnx方法
			        //锁未被占用，上锁成功
			        if(redisTemplate.opsForValue().setIfAbsent(key, value)) {
			            return true;
			        }
			        //锁已经被占用
			
			        //获取当前数据库中的记录
			        String currentValue = redisTemplate.opsForValue().get(key);
			        //若上一次锁的时间，小于当前时间，则锁已经过期
			        if (!StringUtils.isEmpty(currentValue)
			                && Long.parseLong(currentValue) < System.currentTimeMillis()) {
			            //获取上一个锁的时间，同时获得锁
			            String oldValue = redisTemplate.opsForValue().getAndSet(key, value);
			            //多线程并发时，第一个执行getAndSet方法的线程获得锁，其他线程依旧需要等待
			            if (!StringUtils.isEmpty(oldValue) && oldValue.equals(currentValue)) {
			                return true;
			            }
			        }
			
			        return false;
				}
			```
		2. 解锁
			```
			/**
			 * 解锁
			 * @param key
			 * @param value
			 */
			public void unlock(String key, String value) {
				try {
					String currentValue = redisTemplate.opsForValue().get(key);
					if (!StringUtils.isEmpty(currentValue) && currentValue.equals(value)) {
						redisTemplate.opsForValue().getOperations().delete(key);
					}
				}catch (Exception e) {
					log.error("【redis分布式锁】解锁异常, {}", e);
				}
      	}
      	```
      3. 在需要使用的地方注入RedisLock对象，调用方法。
      ```
		//加锁
		  long time = System.currentTimeMillis() + TIMEOUT;
		  if (!redisLock.lock(productId, String.valueOf(time))) {
            throw new SellException(101, "被挤爆啦，请稍后再试~~");
		  }
		
		
		//解锁
		  redisLock.unlock(productId,String.valueOf(time));
		```
## Redis缓存

1. 引入依赖
  ```
  <dependency>
  	<groupId>org.springframework.boot</groupId>
  	<artifactId>spring-boot-starter-cache</artifactId>
  </dependency>
  ```

2. 在启动类SellApplication上加一个注解@EnableCaching

3. 对具体方法添加注解，使用Redis缓存

      1. @Cacheable

            1. 在需要使用缓存的页面所对应的方法上，使用@Cacheable，第一次运行该方法时，会创建对应数据库，后续不再执行方法内的步骤，直接从Redis数据库中取数据。

                  ```
                  @Cacheable(cacheNames = "product",key = "123")
                  ```

            ​	2. 注意页面返回的结果必须要实现序列化，可以通过GenerateSerialVersionUID小插件实现

            ​	3. 将返回结果的类implements Serializable

            ​	4. Ctrl + Shift + Y(自定义使用插件的快捷键）

            5. 使用http://sellproject.nat300.top/sell/buyer/product/list进行测试，查看Redis数据库中的值
            6. 可以看到Redis数据库中有了resultVO的序列化结果
            7. 此后再访问该网址，直接使用数据库中的缓存

      2. @CachePut

            在对数据库中的值进行修改时，需要更新数据库，使用@CachePut注解对save()进行注解，这样在每次更新数据库时，同步更新缓存。但是其返回值必须和数据库建立时存储的值类型一样，不然序列化结果会出错。

            ```
            //CacheNames为Redis数据库名，key若不填，则会默认为函数的入参
            @CachePut(cacheNames = "product",key = "123")
            ```

        3. @CacheEvict：也可以先删除对应的数据库，后面使用到的时候再次建立，来完成Redis数据库的更新

           ```
           // 删除product数据库
           @CacheEvict(cacheNames = "product",key = "123")
           ```


4. condition的使用

   ```
   // key的值为函数入参，condition条件满足时，才会存入数据库,若数据库已经存在缓存，也要满足条件才能取缓存
   @Cacheable(cacheNames = "product",key = "#sellerId", condition = "#sellerId.length() > 3")
   public ResultVO list(@RequestParam("sellerId") String sellerId){}
   ```

5. unless的使用

   ```
   // unless可以排除结果错误的情况
   @Cacheable(cacheNames = "product",key = "#sellerId", unless = "#result.getCode() != 0")
   ```

# 13. 项目部署

## java -jar启动

1. 打开Git CMD，进入到项目的目录下

   ```
   cd E:\workspace\sell
   ```

2. 打包

   ```
   # 默认打包前会进行单元测试，使用-Dmaven.test.skip=true跳过单元测试
   mvn clean package -Dmaven.test.skip=true
   ```

3. 通过在pom.xml的<build></build>结构体内定义fileName，可以指定jar包的名称

   ```
   <finalName>sell</finalName>
   ```

4. 查看打包成功的jar

   ```
   dir target
   ```

5. 将打成的jar包移到虚拟机下。

   ```
   scp target/sell.jar root@192.168.1.6:/opt/javaapps
   ```

6. 此时可以在虚拟机下启动jar包

   ```
   java -jar sell.jar
   //可使用-Dserver.port=8090指定端口号
   java -jar -Dserver.port=8090 sell.jar
   //可使用—Dspring.profiles.active=dev来指定开发环境，也可以=prod来指定生产环境
   java -jar —Dspring.profiles.active=dev sell.jar
   //-D + application.yml中的配置项的所有前缀，来修改配置
   ```

   访问http://192.168.1.6:8090/sell/buyer/product/list?sellerId=1进行测试，可以正确访问。

## 多环境

1. 开发环境，即为一直配置的application.yml,改名为application-dev

2. 生产环境，新建application-prod.yml,其中内容和application-dev基本一样，只删去了显示数据库的配置，即下列语句

   ```
   jpa:
       show-sql: true
   ```

3. 新建application.yml并配置

   ```
   spring:
     profiles:
       active: dev
   ```

# 14. 项目总结

- 项目分析设计
- 微信特性
- 微信支付与退款
- Token认证
- WebSocket消息
- Redis缓存+分布式锁

